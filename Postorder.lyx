#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\providecommand{\thmautorefname}{Theorem}
\providecommand{\corautorefname}{Corollary}
\providecommand{\lemautorefname}{Lemma}
\end_preamble
\use_default_options true
\begin_modules
algolyx
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Inserting in Postorder by Splaying Takes Linear Time
\end_layout

\begin_layout Author
Caleb Levy
\end_layout

\begin_layout Abstract
Define 
\emph on
splay insertion 
\emph default
by first inserting a node into a tree at the location where the binary search
 hits a null node, and then splaying that node.
 We prove that starting from an empty tree, splay-insertion of a sequence
 
\begin_inset Formula $X$
\end_inset

 which is a postorder for some tree takes 
\begin_inset Formula $3\left|X\right|$
\end_inset

 rotations.
\end_layout

\begin_layout Section
Postorder and Pattern Avoidance
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\root}{\operatorname{root}}
{\textnormal{root}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\leftnode}{\operatorname{left}}
{\textnormal{left}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\rightnode}{\operatorname{right}}
{\textnormal{right}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\postorder}{\operatorname{postorder}}
{\textnormal{postorder}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\treap}{\operatorname{treap}}
{\textnormal{treap}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\parent}{\operatorname{parent}}
{\textnormal{parent}}
\end_inset


\end_layout

\begin_layout Standard
We define the postorder sequence of a tree 
\begin_inset Formula $T$
\end_inset

 in the usual recursive way: letting 
\begin_inset Formula $x=\root\left(T\right)$
\end_inset

, we define 
\begin_inset Formula $\postorder\left(T\right)=\left(\postorder\left(\leftnode\left(x\right)\right),\postorder\left(\rightnode\left(x\right)\right),x\right)$
\end_inset

, where the postorder of an empty tree is empty.
 
\end_layout

\begin_layout Standard
The following definitions and theorems are modelled directly after 
\begin_inset CommandInset citation
LatexCommand cite
after "Lemma 1.4"
key "Kozma2016a"

\end_inset

.
 Two sequences 
\begin_inset Formula $A=\left(a_{1}\dots a_{n}\right)$
\end_inset

 and 
\begin_inset Formula $B=\left(b_{1}\dots b_{n}\right)$
\end_inset

 of the same length are 
\emph on
order-isomorphic 
\emph default
if their entries have the same relative order, i.e.
 
\begin_inset Formula $a_{i}<a_{j}\iff b_{i}<b_{j}$
\end_inset

.
 Hence 
\begin_inset Formula $\left(581\right)$
\end_inset

 is order-isomorphic to 
\begin_inset Formula $\left(231\right)$
\end_inset

.
 A sequence 
\begin_inset Formula $A$
\end_inset

 is 
\emph on

\begin_inset Formula $\pi$
\end_inset

-avoiding 
\emph default
if it has no subsequence that is order-isomorphic with 
\begin_inset Formula $\pi$
\end_inset

, otherwise we say it contains 
\begin_inset Formula $\pi$
\end_inset

.
 If 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Formula $\pi$
\end_inset

-avoiding, then all subsequences of 
\begin_inset Formula $A$
\end_inset

 are 
\begin_inset Formula $\pi$
\end_inset

-avoding.
\end_layout

\begin_layout Theorem
A sequence 
\begin_inset Formula $X$
\end_inset

 is a postorder if and only if it is 
\begin_inset Formula $312$
\end_inset

-avoding.
\end_layout

\begin_layout Proof
We define a bijection that maps arbitrary 
\begin_inset Formula $312$
\end_inset

-avoiding permutations to a BST over 
\begin_inset Formula $\left[n\right]$
\end_inset

.
 Let 
\begin_inset Formula $\pi$
\end_inset

 be a 
\begin_inset Formula $312$
\end_inset

-avoiding permutation of length 
\begin_inset Formula $n$
\end_inset

.
 Let 
\begin_inset Formula $L=\left(\pi_{1}\dots\pi_{k}\right)$
\end_inset

 be the longest contiguous subsequence of 
\begin_inset Formula $\pi$
\end_inset

 consisting of elements less than 
\begin_inset Formula $\pi_{n}$
\end_inset

.
 Observe that all elements in 
\begin_inset Formula $R=\left(\pi_{k+1}\dots\pi_{n-1}\right)$
\end_inset

 are greater than 
\begin_inset Formula $\pi_{n}$
\end_inset

, for otherwise 
\begin_inset Formula $\pi$
\end_inset

 would have a subsequence order-isomorphic to 
\begin_inset Formula $312$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
In particular, 
\begin_inset Formula $\left(\pi_{k+1},\pi_{m},\pi_{n}\right)$
\end_inset

 where 
\begin_inset Formula $k+1<m<n$
\end_inset

 would be isomorphic to 
\begin_inset Formula $312$
\end_inset

.
\end_layout

\end_inset

 (One of both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 may be empty.) By induction, we build a BST with 
\begin_inset Formula $\pi_{n}$
\end_inset

 as the root and the BSTs recursively built from 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 as the left, respectively right subtree of the root.
 (The BST built of an empty sequence is empty.) The map is injective by induction.
\end_layout

\begin_layout Proof
The reverse mapping is as follows: given a BST 
\begin_inset Formula $T$
\end_inset

, build a permutation 
\begin_inset Formula $\pi$
\end_inset

, with 
\begin_inset Formula $\pi_{n}=\root\left(T\right)$
\end_inset

, preceeded by the sequences 
\begin_inset Formula $\pi_{L}$
\end_inset

 and 
\begin_inset Formula $\pi_{R}$
\end_inset

 built recursively from the left, respectively right subtree of 
\begin_inset Formula $\root\left(T\right)$
\end_inset

.
 (The sequence built of an empty BST is empty).
 The resulting permutation of 
\begin_inset Formula $\pi$
\end_inset

 is known as the postorder sequence.
\end_layout

\begin_layout Proof
We argue that 
\begin_inset Formula $\pi$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding.
 By induction, 
\begin_inset Formula $\pi_{L}$
\end_inset

 and 
\begin_inset Formula $\pi_{R}$
\end_inset

 are 
\begin_inset Formula $312$
\end_inset

-avoiding.
 Suppose for contradiction that 
\begin_inset Formula $\pi$
\end_inset

 contains a subsequence 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 such that 
\begin_inset Formula $y<z<x$
\end_inset

.
 If 
\begin_inset Formula $z=\pi_{n}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

 cannot be in 
\begin_inset Formula $\pi_{L}$
\end_inset

, since entries of 
\begin_inset Formula $\pi_{L}$
\end_inset

 are smaller than 
\begin_inset Formula $z$
\end_inset

.
 But then 
\begin_inset Formula $y$
\end_inset

 is in 
\begin_inset Formula $\pi_{R}$
\end_inset

, contradicting 
\begin_inset Formula $y<z$
\end_inset

.
 If 
\begin_inset Formula $z$
\end_inset

 is in 
\begin_inset Formula $\pi_{R}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

 must be in 
\begin_inset Formula $\pi_{L}$
\end_inset

 (since otherwise 
\begin_inset Formula $\pi_{R}$
\end_inset

 would contain 
\begin_inset Formula $312$
\end_inset

), this time contradicting that 
\begin_inset Formula $z<x$
\end_inset

.
 Thus 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, and 
\begin_inset Formula $z$
\end_inset

 are in 
\begin_inset Formula $\pi_{L}$
\end_inset

, contradicting that 
\begin_inset Formula $\pi_{L}$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding.
\end_layout

\begin_layout Section
Insertion Trees
\end_layout

\begin_layout Standard
An insertion tree for a permutation 
\begin_inset Formula $\pi$
\end_inset

 is the binary search tree obtained by starting from an empty tree and inserting
 nodes in order of their first appearence in 
\begin_inset Formula $\pi$
\end_inset

, with no further adjustment in between.
 Alternatively, if 
\begin_inset Formula $\pi\in S_{n}$
\end_inset

, then the insertion tree 
\begin_inset Formula $T$
\end_inset

 for 
\begin_inset Formula $\pi$
\end_inset

 is 
\begin_inset Formula $\treap\left(\left(1\dots n\right),\pi\right)=\treap\left(\pi\right)$
\end_inset

, as defined by Kozma.
 
\end_layout

\begin_layout Standard
The following lemma has been observed in a more general form many times.
 Despite being very intuitively straightforward, the proof given here is
 surprisingly tedious.
 I suspect it can be made more elegant.
 I provide the proof here for completeness, since it is central to proving
 postorder insertion takes linear time.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\pi$
\end_inset

 be a permutation.
 Then both the paths encountered by using splay-insert on the nodes of 
\begin_inset Formula $\pi$
\end_inset

 starting from an empty tree, and the final tree produced by doing so, will
 be identical those obtained by splaying the sequence 
\begin_inset Formula $\pi$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

.
\end_layout

\begin_layout Proof
We prove by induction on the length of 
\begin_inset Formula $\pi$
\end_inset

.
 If 
\begin_inset Formula $\pi=\varnothing$
\end_inset

 then there are no splay paths and both procedures end in an empty tree.
 Assume the lemma is true for permutations of length at most 
\begin_inset Formula $n-1$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\pi=\left(\pi_{1}\dots\pi_{n}\right)$
\end_inset

, and denote 
\begin_inset Formula $\pi_{<n}=\left(\pi_{1}\dots\pi_{n-1}\right)$
\end_inset

.
 Define 
\begin_inset Formula $T_{0}=\treap\left(\pi\right)$
\end_inset

 and 
\begin_inset Formula $T_{0}'=\treap\left(\pi_{<n}\right)$
\end_inset

, and for 
\begin_inset Formula $1\le i\le n-1$
\end_inset

 denote by 
\begin_inset Formula $T_{i}$
\end_inset

 and 
\begin_inset Formula $T_{i}'$
\end_inset

 the trees obtained by splaying 
\begin_inset Formula $\pi_{i}$
\end_inset

 in 
\begin_inset Formula $T_{i-1}$
\end_inset

 and 
\begin_inset Formula $T_{i-1}'$
\end_inset

, respectively.
 We claim that 
\begin_inset Formula $T_{i}$
\end_inset

 is formed by adding 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf of 
\begin_inset Formula $T_{i}'$
\end_inset

.
\end_layout

\begin_layout Proof
Clearly this is true of 
\begin_inset Formula $i=0$
\end_inset

.
 Suppose the claim is true for 
\begin_inset Formula $1\le i\le k-1<n-1$
\end_inset

, so that 
\begin_inset Formula $T_{k-1}$
\end_inset

 is formed by adding 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf to 
\begin_inset Formula $T_{k-1}'$
\end_inset

.
 In particular, this ensures that 
\end_layout

\begin_deeper
\begin_layout Itemize
the access paths for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in 
\begin_inset Formula $T_{k-1}$
\end_inset

 and 
\begin_inset Formula $T_{k-1}'$
\end_inset

 are identical, and
\end_layout

\begin_layout Itemize
all subtrees hanging from the access path for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in 
\begin_inset Formula $T_{k-1}$
\end_inset

 are identical to those in 
\begin_inset Formula $T_{k-1}'$
\end_inset

, except that one of the subtrees in 
\begin_inset Formula $T_{k-1}$
\end_inset

 contains 
\begin_inset Formula $\pi_{n}$
\end_inset

 added as a leaf.
\end_layout

\end_deeper
\begin_layout Proof
Recall that:
\end_layout

\begin_deeper
\begin_layout Enumerate
splaying cannot alter the shapes of subtrees rooted at children of nodes
 along a splay path, and 
\end_layout

\begin_layout Enumerate
the final positions of all nodes in a splay path, and all subtrees of nodes
 on the splay path, depend solely on the shape of the splay path prior to
 splaying.
\end_layout

\end_deeper
\begin_layout Proof
Using the above bullet points, we conclude that after splaying 
\begin_inset Formula $\pi_{k}$
\end_inset

, the nodes of the access paths for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in both 
\begin_inset Formula $T_{k}$
\end_inset

 and 
\begin_inset Formula $T_{k}'$
\end_inset

 have the same positions, and the subtrees of the access paths are also
 positioned identically, with both sets of subtrees unaltered in their shapes.
 Hence all nodes in 
\begin_inset Formula $T_{k}$
\end_inset

 and 
\begin_inset Formula $T_{k}'$
\end_inset

 have identical positions, spare that 
\begin_inset Formula $\pi_{n}$
\end_inset

 is situated as a leaf of some subtree in 
\begin_inset Formula $T_{k}'$
\end_inset

.
 We thus have that 
\begin_inset Formula $T_{i}$
\end_inset

 is obtained by inserting 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf of 
\begin_inset Formula $T_{i}'$
\end_inset

 for 
\begin_inset Formula $1\le i\le n-1$
\end_inset

.
 
\end_layout

\begin_layout Proof
We may now summarize:
\end_layout

\begin_deeper
\begin_layout Enumerate
The 
\emph on
splay paths
\emph default
 encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are identical to those encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the above arguments.)
\end_layout

\begin_layout Enumerate
The 
\emph on
tree 
\begin_inset Formula $T_{n-1}$
\end_inset

 produced
\emph default
 by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 is the same as the tree 
\begin_inset Formula $T_{n-1}'$
\end_inset

 produced by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

 and then inserting 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf.
 (By the above arguments.)
\end_layout

\begin_layout Enumerate
The 
\emph on
splay paths 
\emph default
encountered by splay-inserting the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 are the same as the splay paths encountered by splaying the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the inductive hypothesis on 
\begin_inset Formula $\pi_{n-1}$
\end_inset

.)
\end_layout

\begin_layout Enumerate
The 
\emph on
tree produced
\emph default
 by splay-inserting the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 is the same as that produced by splaying the sequence 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the inductive hypothesis on 
\begin_inset Formula $\pi_{n-1}$
\end_inset

.)
\end_layout

\end_deeper
\begin_layout Proof
Hence, the splay paths encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are the same as 
\emph on
splay-inserting
\emph default
 
\begin_inset Formula $\pi_{<n}$
\end_inset

.
 When we go to 
\emph on
splay-insert
\emph default
 
\begin_inset Formula $\pi_{n}$
\end_inset

, we will insert it as a leaf into 
\begin_inset Formula $T_{n-1}'$
\end_inset

.
 By the symmetric order constraints, its position will be identical to that
 of the leaf 
\begin_inset Formula $\pi_{n}$
\end_inset

 in 
\begin_inset Formula $T_{n-1}$
\end_inset

.
 To complete the proof, we note that splaying the same node 
\begin_inset Formula $\pi_{n}$
\end_inset

 in identical trees will result in identical splay paths and identical trees.
\end_layout

\begin_layout Standard
Most of the busywork in that proof seems to be showing that if I add a leaf
 to the starting tree, and then splay the same sequence, then there will
 be no difference in the execution.
\end_layout

\begin_layout Section
Combs (Insertion Trees of Postorders)
\end_layout

\begin_layout Standard
Knowing that splay-insertion of a postorder 
\begin_inset Formula $\pi$
\end_inset

 is identical to splaying 
\begin_inset Formula $\pi$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

, it is natural to enquire about the nature of 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "Chaudhuri1991"

\end_inset

, Chaudhuri and and Hoft show that splaying a search tree in its own 
\emph on
preorder
\emph default
 takes linear time.
 The fact 
\begin_inset Formula $\treap\left(\operatorname{preorder}\left(T\right)\right)=T$
\end_inset

 may obscure the fact that this is identical 
\emph on
splay-inserting
\emph default
 in preorder, but their problem is fundamentally identical.
 The insertion trees produced by postorders have a very simple, and somewhat
 surprising structure.
 In what follows, 
\begin_inset Formula $x\prec_{\pi}y$
\end_inset

, or simply 
\begin_inset Formula $x\prec y$
\end_inset

 denotes that 
\begin_inset Formula $x$
\end_inset

 precedes 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\pi$
\end_inset

 be a postorder.
 Then all descendents of left children in 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are left children.
\end_layout

\begin_layout Proof
We show that we would otherwise obtain a contradiction.
 Let 
\begin_inset Formula $w$
\end_inset

 be a left child in 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 with a proper descendent 
\begin_inset Formula $z$
\end_inset

 which is a right child.
 Let 
\begin_inset Formula $y=\parent\left(z\right)$
\end_inset

 and 
\begin_inset Formula $x=\parent\left(w\right)$
\end_inset

.
 As 
\begin_inset Formula $z$
\end_inset

 is 
\begin_inset Formula $y$
\end_inset

's right child, 
\begin_inset Formula $y<z$
\end_inset

.
 Because both 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are descendents of 
\begin_inset Formula $w=\leftnode\left(x\right)$
\end_inset

, they are both in 
\begin_inset Formula $x$
\end_inset

's left subtree, hence 
\begin_inset Formula $y<z<x$
\end_inset

.
 Further, 
\begin_inset Formula $y$
\end_inset

 is an ancestor of 
\begin_inset Formula $z$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 is an ancestor of 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Proof
By the properties of the heap-order, 
\begin_inset Formula $y$
\end_inset

 can be an ancestor of 
\begin_inset Formula $z$
\end_inset

 only if 
\begin_inset Formula $y\prec_{\pi}z$
\end_inset

, and similarly we must have 
\begin_inset Formula $x\prec_{\pi}y$
\end_inset

.
 We thus have that 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 is a subsequence of 
\begin_inset Formula $\pi$
\end_inset

, and from the above, 
\begin_inset Formula $\left(xyz\right)$
\end_inset

 is order-isomorphic to 
\begin_inset Formula $312$
\end_inset

, meaning 
\begin_inset Formula $\pi$
\end_inset

 is not a postorder.
\end_layout

\begin_layout Standard
From the above, if 
\begin_inset Formula $\pi$
\end_inset

 is a postorder, 
\begin_inset Formula $T=\treap\left(T\right)$
\end_inset

, the path from 
\begin_inset Formula $\root\left(T\right)$
\end_inset

 to 
\begin_inset Formula $x\in T$
\end_inset

 always consists first of zero or more right children followed by zero or
 more left children.
 The shape this describes in general is a 
\begin_inset Quotes eld
\end_inset

right path
\begin_inset Quotes erd
\end_inset

 with 
\begin_inset Quotes eld
\end_inset

left paths
\begin_inset Quotes erd
\end_inset

 hanging from it to fill in the gaps.
 I will call any such structure a 
\begin_inset Quotes eld
\end_inset

(left-toothed) comb.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Comb"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comb
\end_layout

\end_inset

A 
\emph on
comb
\emph default
 
\begin_inset Formula $C$
\end_inset

 corresponding to the interval partition 
\begin_inset Formula $1\le b_{1}<b_{2}<\cdots<b_{k}=n$
\end_inset

 is a binary search tree with nodes 
\begin_inset Formula $1\dots n$
\end_inset

 whose structure is as follows (for convenience define 
\begin_inset Formula $b_{0}=0$
\end_inset

):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $b_{1}=\root\left(C\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $b_{i+1}=\rightnode\left(b_{i}\right)$
\end_inset

,
\begin_inset space \qquad{}
\end_inset

for 
\begin_inset Formula $1\le i<k$
\end_inset

 when 
\begin_inset Formula $k>1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $j=\leftnode\left(j+1\right)$
\end_inset

, 
\begin_inset space \qquad{}
\end_inset

for 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

 and 
\begin_inset Formula $1\le i\le k$
\end_inset


\end_layout

\end_deeper
\begin_layout Definition
We refer to the interval 
\begin_inset Formula $B_{i}=(b_{i-1},b_{i}]$
\end_inset

 as the 
\begin_inset Formula $i\textsuperscript{th}$
\end_inset

 
\emph on
bin
\emph default
 or 
\emph on

\begin_inset Quotes eld
\end_inset

tooth
\begin_inset Quotes erd
\end_inset

 
\emph default
on the comb.
\end_layout

\begin_layout Standard
Combs have several other properties which are not proven here or used for
 this investigation, but which are interesting:
\end_layout

\begin_layout Itemize
For a postorder 
\begin_inset Formula $\pi$
\end_inset

, the comb given by 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 corresponds to the maximal subsequence 
\begin_inset Formula $\left(\pi_{a_{1}}\dots\pi_{a_{k}}\right)$
\end_inset

 of 
\begin_inset Formula $\pi$
\end_inset

 so that 
\begin_inset Formula $\pi_{j}<\pi_{a_{i}}$
\end_inset

 for 
\begin_inset Formula $j<a_{i}$
\end_inset

, for 
\begin_inset Formula $1\le i\le k$
\end_inset

.
\end_layout

\begin_layout Itemize
For every comb 
\begin_inset Formula $C$
\end_inset

, there is a corresponding postorder sequence whose insertion tree is 
\begin_inset Formula $C$
\end_inset

.
 In fact, the 
\emph on
preorder
\emph default
 of 
\begin_inset Formula $C$
\end_inset

 is also a 
\emph on
postorder
\emph default
 whose insertion tree is 
\begin_inset Formula $C$
\end_inset

.
 Note, however, that the tree whose postorder sequence is 
\begin_inset Formula $C$
\end_inset

's preorder will not (in general) be 
\begin_inset Formula $C$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In fact, this tree may be obtained by reversing the labels on each tooth
 of the comb, and then rotating the whole tree 
\begin_inset Formula $90^{\circ}$
\end_inset

 counterclockwise.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Each division of bins on a comb corresponds to an interval partition of
 
\begin_inset Formula $\left[n\right]$
\end_inset

, which itself corresponds to some subset of 
\begin_inset Formula $\left[n-1\right]$
\end_inset

.
 Hence there are 
\begin_inset Formula $2^{n-1}$
\end_inset

 combs on 
\begin_inset Formula $n$
\end_inset

 nodes.
\end_layout

\begin_layout Section
Traversing the Comb
\end_layout

\begin_layout Standard
By itself, the structure of a comb does not help us very much.
 If 
\begin_inset Formula $\tau$
\end_inset

 is an 
\emph on
arbitrary 
\emph default
permutation (such as the bit reversal permutation described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Wilber1989"

\end_inset

), then even the optimal
\emph on
 
\emph default
algorithm can take super-linear time starting from 
\begin_inset Formula $\treap\left(\tau\right)$
\end_inset

 (or any other tree).
 Further, computing the costs of splaying a postorder starting from an arbitrary
 
\emph on
comb
\emph default
 does not seem much easier than starting from any other tree.
\end_layout

\begin_layout Standard
Given a comb 
\begin_inset Formula $C=\left(B_{1},\dots,B_{k}\right)$
\end_inset

, we want to characterize all permutations 
\begin_inset Formula $\pi$
\end_inset

 so that 
\begin_inset Formula $\pi$
\end_inset

 is a postorder such that 
\begin_inset Formula $\treap\left(\pi\right)=C$
\end_inset

.
 We will call these 
\emph on
matching postorders 
\emph default
for 
\begin_inset Formula $C$
\end_inset

.
 The following subroutine, 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

, will be useful:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $\textsc{MultiPush}\left(Q,R\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Input Two stacks 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Algorithm (num)
while 
\begin_inset Formula $R\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{Push}\left(Q,\textsc{Pop}\left(R\right)\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
endwhile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few notes and conventions for what follows.
 The top of a stack is on the 
\emph on
left
\emph default
.
 Each bin 
\begin_inset Formula $B_{i}$
\end_inset

 is treated as a stack of items 
\begin_inset Formula $\left\{ b_{i-1}+1,b_{i-1}+2,\dots,b_{i}\right\} $
\end_inset

.
 The stack 
\begin_inset Formula $B$
\end_inset

 is treated as a 
\begin_inset Quotes eld
\end_inset

stack of bins.
\begin_inset Quotes erd
\end_inset

 The keyword 
\begin_inset Formula $\textsc{Continue}$
\end_inset

 merely means to continue to the next iteration of the loop.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "MatchingPostorder"

\end_inset


\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset


\begin_inset Formula $\left(C\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Input A nonempty comb 
\begin_inset Formula $C$
\end_inset

 with bins 
\begin_inset Formula $B_{1}\dots B_{k}$
\end_inset

 
\end_layout

\begin_layout Algorithm (num)
* Initialize stacks 
\begin_inset Formula $S={\{}{\}}$
\end_inset

, 
\begin_inset Formula $B={\{}B_{1}\dots B_{k}{\}}$
\end_inset


\end_layout

\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop1"

\end_inset


\end_layout

\begin_layout Algorithm (num)
while 
\begin_inset Formula $S\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\series bold
print 
\series default

\begin_inset Formula $\textsc{Pop}\left(S\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop2"

\end_inset


\end_layout

\begin_layout Algorithm (num)
if 
\begin_inset Formula $S=\varnothing$
\end_inset

 and 
\begin_inset Formula $B\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop3"

\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
elseif 
\begin_inset Formula $B=\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{Continue}$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
else
\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* Choose between 
\begin_inset Formula $\textsc{Continue}$
\end_inset

 and 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop4"

\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
endif
\end_layout

\end_deeper
\begin_layout Algorithm (num)
endwhile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will prove that a permutation 
\begin_inset Formula $\pi$
\end_inset

 is compatible with comb 
\begin_inset Formula $C$
\end_inset

 if and only if it is a possible output of 
\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset

.
\end_layout

\begin_layout Subsection
Outputs are Permutations
\end_layout

\begin_layout Standard
Before proving our main results, we need to perform more basic sanity checks
 on our algorithm.
\end_layout

\begin_layout Lemma
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Correctness
\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 never pops from an empty stack.
\end_layout

\begin_layout Proof
There are four locations in the program at which a 
\begin_inset Formula $\textsc{Pop}$
\end_inset

 can occur: Lines 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
\end_layout

\begin_layout Proof
The first 
\begin_inset Formula $\textsc{Pop}$
\end_inset

 is in the initialization step at Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

.
 Because the comb is nonempty, it will have at least one bin, and therefore
 
\begin_inset Formula $B$
\end_inset

 will be nonempty when 
\begin_inset Formula $\textsc{Pop}\left(B\right)$
\end_inset

 is called.
 The check in the 
\series bold
while
\series default
 loop that 
\begin_inset Formula $S\ne\varnothing$
\end_inset

 ensures that 
\begin_inset Formula $S$
\end_inset

 is nonempty whenever 
\begin_inset Formula $\textsc{Pop}\left(S\right)$
\end_inset

 is called in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

.
 If 
\begin_inset Formula $S$
\end_inset

 
\emph on
is
\emph default
 empty, then the algorithm terminates, and no more pops are performed.
\end_layout

\begin_layout Proof
The call 
\begin_inset Formula $\textsc{Pop}\left(B\right)$
\end_inset

 in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 is only performed after verifying in the preceeding line that 
\begin_inset Formula $B$
\end_inset

 is nonempty.
 Similarly, we are only allowed to proceed to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

 if 
\begin_inset Formula $B$
\end_inset

 is nonempty, at which point we are allowed to choose to pop an element
 from 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Termination"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Termination
\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 always terminates.
\end_layout

\begin_layout Proof
At every iteration of the 
\series bold
while
\series default
 loop, one element is removed from 
\begin_inset Formula $S$
\end_inset

.
 The only way elements may be added to 
\begin_inset Formula $S$
\end_inset

 is by a 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

 from a bin on top of 
\begin_inset Formula $B$
\end_inset

.
 There are at most 
\begin_inset Formula $k$
\end_inset

 bins totalling 
\begin_inset Formula $n$
\end_inset

 elements which may be added to 
\begin_inset Formula $S$
\end_inset

.
 Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, it is removed from 
\begin_inset Formula $B$
\end_inset

 and its elements are emptied.
 Hence 
\begin_inset Formula $S$
\end_inset

 may increase in size at most 
\begin_inset Formula $n$
\end_inset

 times, and decreases in size at every iteration of the while loop.
 Thus 
\begin_inset Formula $S$
\end_inset

 will be empty after at most 
\begin_inset Formula $n$
\end_inset

 iterations, at which point loop terminates.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "S-is-emptied"

\end_inset

Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, every element in that bin will eventually be popped from 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Proof
The algorithm always terminates, and the only way for it to terminate is
 when 
\begin_inset Formula $S$
\end_inset

 is empty.
 The only mechanism by which items are removed from 
\begin_inset Formula $S$
\end_inset

 is when they are popped at Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

.
 Hence once the items of a bin are added to 
\begin_inset Formula $S$
\end_inset

, they will all eventually be popped.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "All-bins-added"

\end_inset

Every bin is added to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
We will use induction on 
\begin_inset Formula $k$
\end_inset

.
 Observe that when 
\begin_inset Formula $k=1$
\end_inset

, the bin 
\begin_inset Formula $B_{1}$
\end_inset

 is added to 
\begin_inset Formula $S$
\end_inset

 in the initialization stage.
 Suppose that for combs with 
\begin_inset Formula $k-1$
\end_inset

 bins, all bins will be added to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $C$
\end_inset

 be a comb with 
\begin_inset Formula $k$
\end_inset

 bins, and consider the execution of the algorithm immediately after 
\begin_inset Formula $B_{k-1}$
\end_inset

 is added to 
\begin_inset Formula $S$
\end_inset

, either in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
 In all three cases, 
\begin_inset Formula $S$
\end_inset

 is nonempty, and the algorithm will proceed to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 after the 
\series bold
while
\series default
 loop.
\end_layout

\begin_layout Proof
After Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

, one of three things will happen.
 First, if 
\begin_inset Formula $S$
\end_inset

 is empty, then the algorithm will move to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

, and add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack.
 If 
\begin_inset Formula $S$
\end_inset

 is nonempty, we will proceed to 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
 If the algorithm chooses to add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack, we are done.
 Otherwise, the algorithm may choose to continue to the next iteration of
 the 
\series bold
while
\series default
 loop.
 Each time it does so, 
\begin_inset Formula $S$
\end_inset

 will decrease by one element.
 Hence we can only choose not to add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack a finite number of times before eventually triggering Line
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

, which will add 
\begin_inset Formula $B_{k}$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "Items-appear-at-least-once"

\end_inset

Every element in the comb 
\begin_inset Formula $C$
\end_inset

 appears in the output of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

.
\end_layout

\begin_layout Proof
Every element in comb 
\begin_inset Formula $C$
\end_inset

 is in one of the bins.
 Every bin is added to 
\begin_inset Formula $S$
\end_inset

 by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "All-bins-added"

\end_inset

.
 Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, all of the bin's elements will eventually be popped from 
\begin_inset Formula $S$
\end_inset

 by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "S-is-emptied"

\end_inset

.
 Every element popped from 
\begin_inset Formula $S$
\end_inset

 is printed in the output, hence all elements in 
\begin_inset Formula $C$
\end_inset

 appear in the output.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Items-appear-at-most-once"

\end_inset

No element of 
\begin_inset Formula $C$
\end_inset

 appears more than once in the output.
\end_layout

\begin_layout Proof
The bins of 
\begin_inset Formula $C$
\end_inset

 form an interval partition of 
\begin_inset Formula $\left[n\right]$
\end_inset

, hence each element appears in exactly one bin, and only once in that bin.
 As each bin is destroyed once its elements are added to 
\begin_inset Formula $S$
\end_inset

, the elements of a bin can only be added to 
\begin_inset Formula $S$
\end_inset

 once.
 The 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

 of popped bins is the only mechanism by which items enter 
\begin_inset Formula $S$
\end_inset

.
 Taken together, these mean that no element of 
\begin_inset Formula $C$
\end_inset

 enters 
\begin_inset Formula $S$
\end_inset

 more than once.
\end_layout

\begin_layout Theorem
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 outputs a permutation of the nodes of 
\begin_inset Formula $C$
\end_inset

 and then terminates.
\end_layout

\begin_layout Proof
By Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "Items-appear-at-least-once"

\end_inset

, every node in 
\begin_inset Formula $C$
\end_inset

 appears in the output, and by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Items-appear-at-most-once"

\end_inset

, no node appears more than once, meaning 
\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset

 outputs a permutation.
 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Termination"

\end_inset

, the algorithm then terminates.
\end_layout

\begin_layout Subsection
Outputs are Valid Postorders
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $C$
\end_inset

 be a comb corresponding to partition 
\begin_inset Formula $1\le b_{1}<\dots<b_{k}=n$
\end_inset

, 
\begin_inset Formula $\tau$
\end_inset

 a permutation of 
\begin_inset Formula $\left[n\right]$
\end_inset

, and 
\begin_inset Formula $T=\treap\left(\tau\right)$
\end_inset

.
 Then 
\begin_inset Formula $T=C$
\end_inset

 if and only if:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $b_{i}\prec_{\tau}b_{j}$
\end_inset

 for 
\begin_inset Formula $1\le i<j\le k$
\end_inset

, and
\end_layout

\begin_layout Enumerate
\begin_inset Formula $j\prec_{\tau}i$
\end_inset

 for 
\begin_inset Formula $b_{l-1}<i<j\le b_{l}$
\end_inset

 and 
\begin_inset Formula $1\le l\le k$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Suppose 
\begin_inset Formula $\tau$
\end_inset

 satisfies conditions 1 and 2.
 We must show 
\begin_inset Formula $T$
\end_inset

 satisfies the three properties of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Comb"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
(The root is 
\begin_inset Formula $b_{1}$
\end_inset

.) By condition 1, 
\begin_inset Formula $b_{1}\prec_{\tau}b_{i}$
\end_inset

 for 
\begin_inset Formula $2\le i\le k$
\end_inset

.
 Furthermore, 
\begin_inset Formula $b_{1}\prec_{\tau}j$
\end_inset

 for 
\begin_inset Formula $1\le j<b_{1}$
\end_inset

 by condition 2.
 Finally by transitivity of the order relation, for all 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

 over 
\begin_inset Formula $1<i\le k$
\end_inset

, we have 
\begin_inset Formula $b_{1}\prec_{\tau}b_{i}\prec_{\tau}j$
\end_inset

.
 Thus 
\begin_inset Formula $b_{1}$
\end_inset

 is the first element of 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $b_{1}=\root\left(T\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
(The right path is 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

.) If 
\begin_inset Formula $k=1$
\end_inset

 then the root 
\begin_inset Formula $b_{1}=n$
\end_inset

 is the greatest element in 
\begin_inset Formula $T$
\end_inset

, and all other nodes appear in 
\begin_inset Formula $b_{1}$
\end_inset

's left subtree, making 
\begin_inset Formula $b_{1}$
\end_inset

 the sole member of the right path.
 We induct on 
\begin_inset Formula $k$
\end_inset

.
 Suppose 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $k$
\end_inset

-bins.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

By the heap-condition on first-access time and the symmetric order on the
 keys, the right child of 
\begin_inset Formula $b_{k-1}$
\end_inset

 in 
\begin_inset Formula $T$
\end_inset

 is the first node greater than 
\begin_inset Formula $b_{k-1}$
\end_inset

 appearing after 
\begin_inset Formula $b_{k-1}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
 If 
\begin_inset Formula $b_{k-1}<j<b_{k}$
\end_inset

 then condition 2 assures us that 
\begin_inset Formula $b_{k}\prec_{\tau}j$
\end_inset

.
 As 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $k$
\end_inset

 bins, 
\begin_inset Formula $b_{k}=\max\left(\tau\right)$
\end_inset

, hence 
\begin_inset Formula $b_{k}$
\end_inset

 has no right children, and no elements greater than 
\begin_inset Formula $b_{k-1}$
\end_inset

 appear before 
\begin_inset Formula $b_{k}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Summarizing, 
\begin_inset Formula $b_{1}$
\end_inset

 is the root and 
\begin_inset Formula $b_{i+1}=\rightnode\left(b_{i}\right)$
\end_inset

 for 
\begin_inset Formula $1<i\le k$
\end_inset

.
 Furthermore as 
\begin_inset Formula $b_{k}=\max\left(\tau\right)$
\end_inset

, 
\begin_inset Formula $b_{k}$
\end_inset

 has no right child, and thus the nodes 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 form the right path of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Enumerate
(The left subtrees of 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 are chains.)
\series bold
 
\series default
From above, the nodes 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 form the right path of 
\begin_inset Formula $T$
\end_inset

, hence the symmetric order implies that the left subtree of 
\begin_inset Formula $b_{i}$
\end_inset

 consists exactly of the nodes 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

.
 We use induction on the length of the chains hanging from each 
\begin_inset Formula $b_{i}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

If 
\begin_inset Formula $b_{i-1}$
\end_inset

 is the predecessor of 
\begin_inset Formula $b_{i}$
\end_inset

 in symmetric order then 
\begin_inset Formula $b_{i}$
\end_inset

's left subtree is empty, vacously matching condition 3 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Comb"

\end_inset

.
 Suppose that all left subtrees of the right path with at least 
\begin_inset Formula $j-1$
\end_inset

 nodes begin with a leftward chain containing the 
\begin_inset Formula $j-1$
\end_inset

 largest nodes of the subtree, and that 
\begin_inset Formula $b_{i}$
\end_inset

 has a left subtree with 
\begin_inset Formula $l\ge j$
\end_inset

 nodes.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Let 
\begin_inset Formula $a_{0}=b_{i}>a_{1}>a_{2}>\cdots>a_{l}$
\end_inset

 be the nodes of that subtree along with 
\begin_inset Formula $b_{i}$
\end_inset

.
 By the inductive hypothesis, nodes 
\begin_inset Formula $a_{0}\dots a_{j-1}$
\end_inset

 are (sometimes not proper) ancestors of 
\begin_inset Formula $a_{j-1}$
\end_inset

, thus the symmetric order implies that nodes 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 are in the left subtree of 
\begin_inset Formula $a_{j-1}$
\end_inset

, hence one of 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 is the left child of 
\begin_inset Formula $a_{j-1}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The heap condition on first access time implies the left child of 
\begin_inset Formula $a_{j-1}$
\end_inset

 is the first node among 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 appearing subsequent to 
\begin_inset Formula $a_{j-1}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
 Condition 2 of the theorem implies that 
\begin_inset Formula $a_{j}\prec_{\tau}a_{h}$
\end_inset

 for 
\begin_inset Formula $j<h<l$
\end_inset

, hence 
\begin_inset Formula $a_{j}=\leftnode\left(a_{j-1}\right)$
\end_inset

, affirming the theorem.
\end_layout

\end_deeper
\begin_layout Proof
Proving the other direction is more straightforward.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Outputs are Matching Postorders
\end_layout

\end_inset

Suppose that 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $n$
\end_inset

 elements, and for 
\begin_inset Formula $1\le i\le n$
\end_inset

, let 
\begin_inset Formula $\pi_{\le i}=\left(\pi_{1}\dots\pi_{i}\right)$
\end_inset

 denote the items printed during the first 
\begin_inset Formula $i$
\end_inset

 executions of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

.
 Then for 
\begin_inset Formula $1\le i\le n$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\pi_{\le i}$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding, and
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\treap\left(\pi_{\le i}\right)$
\end_inset

 is a connected subtree of the root of 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/Users/clevy/Grad/library"
options "plain"

\end_inset


\end_layout

\end_body
\end_document

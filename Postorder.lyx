#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\providecommand{\thmautorefname}{Theorem}
\providecommand{\corautorefname}{Corollary}
\providecommand{\lemautorefname}{Lemma}
\end_preamble
\use_default_options true
\begin_modules
algolyx
theorems-ams
enumitem
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Inserting in Postorder by Splaying Takes Linear Time
\end_layout

\begin_layout Author
Caleb Levy
\end_layout

\begin_layout Abstract
Define 
\emph on
splay insertion 
\emph default
by first inserting a node into a tree at the location where the binary search
 hits a null node, and then splaying that node.
 We prove that starting from an empty tree, splay-insertion of a sequence
 
\begin_inset Formula $X$
\end_inset

 which is a postorder for some tree takes 
\begin_inset Formula $3\left|X\right|$
\end_inset

 rotations.
\end_layout

\begin_layout Section
Postorder and Pattern Avoidance
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\root}{\operatorname{root}}
{\textnormal{root}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\leftnode}{\operatorname{left}}
{\textnormal{left}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\rightnode}{\operatorname{right}}
{\textnormal{right}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\postorder}{\operatorname{postorder}}
{\textnormal{postorder}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\treap}{\operatorname{treap}}
{\textnormal{treap}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\parent}{\operatorname{parent}}
{\textnormal{parent}}
\end_inset


\end_layout

\begin_layout Standard
We define the postorder sequence of a tree 
\begin_inset Formula $T$
\end_inset

 in the usual recursive way: letting 
\begin_inset Formula $x=\root\left(T\right)$
\end_inset

, we define 
\begin_inset Formula $\postorder\left(T\right)=\left(\postorder\left(\leftnode\left(x\right)\right),\postorder\left(\rightnode\left(x\right)\right),x\right)$
\end_inset

, where the postorder of an empty tree is empty.
 
\end_layout

\begin_layout Standard
The following definitions and theorems are modeled directly after 
\begin_inset CommandInset citation
LatexCommand cite
after "Lemma 1.4"
key "Kozma2016a"

\end_inset

.
 Two sequences 
\begin_inset Formula $A=\left(a_{1}\dots a_{n}\right)$
\end_inset

 and 
\begin_inset Formula $B=\left(b_{1}\dots b_{n}\right)$
\end_inset

 of the same length are 
\emph on
order-isomorphic 
\emph default
if their entries have the same relative order, i.e.
 
\begin_inset Formula $a_{i}<a_{j}\iff b_{i}<b_{j}$
\end_inset

.
 Hence 
\begin_inset Formula $\left(581\right)$
\end_inset

 is order-isomorphic to 
\begin_inset Formula $\left(231\right)$
\end_inset

.
 A sequence 
\begin_inset Formula $A$
\end_inset

 is 
\emph on

\begin_inset Formula $\pi$
\end_inset

-avoiding 
\emph default
if it has no subsequence that is order-isomorphic with 
\begin_inset Formula $\pi$
\end_inset

, otherwise we say it contains 
\begin_inset Formula $\pi$
\end_inset

.
 If 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Formula $\pi$
\end_inset

-avoiding, then all subsequences of 
\begin_inset Formula $A$
\end_inset

 are 
\begin_inset Formula $\pi$
\end_inset

-avoding.
\end_layout

\begin_layout Theorem
A sequence 
\begin_inset Formula $X$
\end_inset

 is a postorder if and only if it is 
\begin_inset Formula $312$
\end_inset

-avoding.
\end_layout

\begin_layout Proof
We define a bijection that maps arbitrary 
\begin_inset Formula $312$
\end_inset

-avoiding permutations to a BST over 
\begin_inset Formula $\left[n\right]$
\end_inset

.
 Let 
\begin_inset Formula $\pi$
\end_inset

 be a 
\begin_inset Formula $312$
\end_inset

-avoiding permutation of length 
\begin_inset Formula $n$
\end_inset

.
 Let 
\begin_inset Formula $L=\left(\pi_{1}\dots\pi_{k}\right)$
\end_inset

 be the longest contiguous subsequence of 
\begin_inset Formula $\pi$
\end_inset

 consisting of elements less than 
\begin_inset Formula $\pi_{n}$
\end_inset

.
 Observe that all elements in 
\begin_inset Formula $R=\left(\pi_{k+1}\dots\pi_{n-1}\right)$
\end_inset

 are greater than 
\begin_inset Formula $\pi_{n}$
\end_inset

, for otherwise 
\begin_inset Formula $\pi$
\end_inset

 would have a subsequence order-isomorphic to 
\begin_inset Formula $312$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In particular, 
\begin_inset Formula $\left(\pi_{k+1},\pi_{m},\pi_{n}\right)$
\end_inset

 where 
\begin_inset Formula $k+1<m<n$
\end_inset

 would be isomorphic to 
\begin_inset Formula $312$
\end_inset

.
\end_layout

\end_inset

 (One of both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 may be empty.) By induction, we build a BST with 
\begin_inset Formula $\pi_{n}$
\end_inset

 as the root and the BSTs recursively built from 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 as the left, respectively right subtree of the root.
 (The BST built of an empty sequence is empty.) The map is injective by induction.
\end_layout

\begin_layout Proof
The reverse mapping is as follows: given a BST 
\begin_inset Formula $T$
\end_inset

, build a permutation 
\begin_inset Formula $\pi$
\end_inset

, with 
\begin_inset Formula $\pi_{n}=\root\left(T\right)$
\end_inset

, preceded by the sequences 
\begin_inset Formula $\pi_{L}$
\end_inset

 and 
\begin_inset Formula $\pi_{R}$
\end_inset

 built recursively from the left, respectively right subtree of 
\begin_inset Formula $\root\left(T\right)$
\end_inset

.
 (The sequence built of an empty BST is empty).
 The resulting permutation of 
\begin_inset Formula $\pi$
\end_inset

 is known as the postorder sequence.
\end_layout

\begin_layout Proof
We argue that 
\begin_inset Formula $\pi$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding.
 By induction, 
\begin_inset Formula $\pi_{L}$
\end_inset

 and 
\begin_inset Formula $\pi_{R}$
\end_inset

 are 
\begin_inset Formula $312$
\end_inset

-avoiding.
 Suppose for contradiction that 
\begin_inset Formula $\pi$
\end_inset

 contains a subsequence 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 such that 
\begin_inset Formula $y<z<x$
\end_inset

.
 If 
\begin_inset Formula $z=\pi_{n}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

 cannot be in 
\begin_inset Formula $\pi_{L}$
\end_inset

, since entries of 
\begin_inset Formula $\pi_{L}$
\end_inset

 are smaller than 
\begin_inset Formula $z$
\end_inset

.
 But then 
\begin_inset Formula $y$
\end_inset

 is in 
\begin_inset Formula $\pi_{R}$
\end_inset

, contradicting 
\begin_inset Formula $y<z$
\end_inset

.
 If 
\begin_inset Formula $z$
\end_inset

 is in 
\begin_inset Formula $\pi_{R}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

 must be in 
\begin_inset Formula $\pi_{L}$
\end_inset

 (since otherwise 
\begin_inset Formula $\pi_{R}$
\end_inset

 would contain 
\begin_inset Formula $312$
\end_inset

), this time contradicting that 
\begin_inset Formula $z<x$
\end_inset

.
 Thus 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, and 
\begin_inset Formula $z$
\end_inset

 are in 
\begin_inset Formula $\pi_{L}$
\end_inset

, contradicting that 
\begin_inset Formula $\pi_{L}$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding.
\end_layout

\begin_layout Section
Insertion Trees
\end_layout

\begin_layout Standard
An insertion tree for a permutation 
\begin_inset Formula $\pi$
\end_inset

 is the binary search tree obtained by starting from an empty tree and inserting
 nodes in order of their first appearance in 
\begin_inset Formula $\pi$
\end_inset

, with no further adjustment in between.
 Alternatively, if 
\begin_inset Formula $\pi\in S_{n}$
\end_inset

, then the insertion tree 
\begin_inset Formula $T$
\end_inset

 for 
\begin_inset Formula $\pi$
\end_inset

 is 
\begin_inset Formula $\treap\left(\left(1\dots n\right),\pi\right)=\treap\left(\pi\right)$
\end_inset

, as defined by Kozma.
 
\end_layout

\begin_layout Standard
The following lemma has been observed in a more general form many times.
 Despite being very intuitively straightforward, the proof given here is
 surprisingly tedious.
 I suspect it can be made more elegant.
 I provide the proof here for completeness, since it is central to proving
 postorder insertion takes linear time.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:InitialTrees"

\end_inset

Let 
\begin_inset Formula $\pi$
\end_inset

 be a permutation.
 Then both the paths encountered by using splay-insert on the nodes of 
\begin_inset Formula $\pi$
\end_inset

 starting from an empty tree, and the final tree produced by doing so, will
 be identical those obtained by splaying the sequence 
\begin_inset Formula $\pi$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

.
\end_layout

\begin_layout Proof
We prove by induction on the length of 
\begin_inset Formula $\pi$
\end_inset

.
 If 
\begin_inset Formula $\pi=\varnothing$
\end_inset

 then there are no splay paths and both procedures end in an empty tree.
 Assume the lemma is true for permutations of length at most 
\begin_inset Formula $n-1$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\pi=\left(\pi_{1}\dots\pi_{n}\right)$
\end_inset

, and denote 
\begin_inset Formula $\pi_{<n}=\left(\pi_{1}\dots\pi_{n-1}\right)$
\end_inset

.
 Define 
\begin_inset Formula $T_{0}=\treap\left(\pi\right)$
\end_inset

 and 
\begin_inset Formula $T_{0}'=\treap\left(\pi_{<n}\right)$
\end_inset

, and for 
\begin_inset Formula $1\le i\le n-1$
\end_inset

 denote by 
\begin_inset Formula $T_{i}$
\end_inset

 and 
\begin_inset Formula $T_{i}'$
\end_inset

 the trees obtained by splaying 
\begin_inset Formula $\pi_{i}$
\end_inset

 in 
\begin_inset Formula $T_{i-1}$
\end_inset

 and 
\begin_inset Formula $T_{i-1}'$
\end_inset

, respectively.
 We claim that 
\begin_inset Formula $T_{i}$
\end_inset

 is formed by adding 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf of 
\begin_inset Formula $T_{i}'$
\end_inset

.
\end_layout

\begin_layout Proof
Clearly this is true of 
\begin_inset Formula $i=0$
\end_inset

.
 Suppose the claim is true for 
\begin_inset Formula $1\le i\le k-1<n-1$
\end_inset

, so that 
\begin_inset Formula $T_{k-1}$
\end_inset

 is formed by adding 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf to 
\begin_inset Formula $T_{k-1}'$
\end_inset

.
 In particular, this ensures that 
\end_layout

\begin_deeper
\begin_layout Itemize
the access paths for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in 
\begin_inset Formula $T_{k-1}$
\end_inset

 and 
\begin_inset Formula $T_{k-1}'$
\end_inset

 are identical, and
\end_layout

\begin_layout Itemize
all subtrees hanging from the access path for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in 
\begin_inset Formula $T_{k-1}$
\end_inset

 are identical to those in 
\begin_inset Formula $T_{k-1}'$
\end_inset

, except that one of the subtrees in 
\begin_inset Formula $T_{k-1}$
\end_inset

 contains 
\begin_inset Formula $\pi_{n}$
\end_inset

 added as a leaf.
\end_layout

\end_deeper
\begin_layout Proof
Recall that:
\end_layout

\begin_deeper
\begin_layout Enumerate
splaying cannot alter the shapes of subtrees rooted at children of nodes
 along a splay path, and 
\end_layout

\begin_layout Enumerate
the final positions of all nodes in a splay path, and all subtrees of nodes
 on the splay path, depend solely on the shape of the splay path prior to
 splaying.
\end_layout

\end_deeper
\begin_layout Proof
Using the above bullet points, we conclude that after splaying 
\begin_inset Formula $\pi_{k}$
\end_inset

, the nodes of the access paths for 
\begin_inset Formula $\pi_{k}$
\end_inset

 in both 
\begin_inset Formula $T_{k}$
\end_inset

 and 
\begin_inset Formula $T_{k}'$
\end_inset

 have the same positions, and the subtrees of the access paths are also
 positioned identically, with both sets of subtrees unaltered in their shapes.
 Hence all nodes in 
\begin_inset Formula $T_{k}$
\end_inset

 and 
\begin_inset Formula $T_{k}'$
\end_inset

 have identical positions, spare that 
\begin_inset Formula $\pi_{n}$
\end_inset

 is situated as a leaf of some subtree in 
\begin_inset Formula $T_{k}'$
\end_inset

.
 We thus have that 
\begin_inset Formula $T_{i}$
\end_inset

 is obtained by inserting 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf of 
\begin_inset Formula $T_{i}'$
\end_inset

 for 
\begin_inset Formula $1\le i\le n-1$
\end_inset

.
 
\end_layout

\begin_layout Proof
We may now summarize:
\end_layout

\begin_deeper
\begin_layout Enumerate
The 
\emph on
splay paths
\emph default
 encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are identical to those encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the above arguments.)
\end_layout

\begin_layout Enumerate
The 
\emph on
tree 
\begin_inset Formula $T_{n-1}$
\end_inset

 produced
\emph default
 by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 is the same as the tree 
\begin_inset Formula $T_{n-1}'$
\end_inset

 produced by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

 and then inserting 
\begin_inset Formula $\pi_{n}$
\end_inset

 as a leaf.
 (By the above arguments.)
\end_layout

\begin_layout Enumerate
The 
\emph on
splay paths 
\emph default
encountered by splay-inserting the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 are the same as the splay paths encountered by splaying the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the inductive hypothesis on 
\begin_inset Formula $\pi_{n-1}$
\end_inset

.)
\end_layout

\begin_layout Enumerate
The 
\emph on
tree produced
\emph default
 by splay-inserting the nodes of 
\begin_inset Formula $\pi_{<n}$
\end_inset

 is the same as that produced by splaying the sequence 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi_{<n}\right)$
\end_inset

.
 (By the inductive hypothesis on 
\begin_inset Formula $\pi_{n-1}$
\end_inset

.)
\end_layout

\end_deeper
\begin_layout Proof
Hence, the splay paths encountered by splaying 
\begin_inset Formula $\pi_{<n}$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are the same as 
\emph on
splay-inserting
\emph default
 
\begin_inset Formula $\pi_{<n}$
\end_inset

.
 When we go to 
\emph on
splay-insert
\emph default
 
\begin_inset Formula $\pi_{n}$
\end_inset

, we will insert it as a leaf into 
\begin_inset Formula $T_{n-1}'$
\end_inset

.
 By the symmetric order constraints, its position will be identical to that
 of the leaf 
\begin_inset Formula $\pi_{n}$
\end_inset

 in 
\begin_inset Formula $T_{n-1}$
\end_inset

.
 To complete the proof, we note that splaying the same node 
\begin_inset Formula $\pi_{n}$
\end_inset

 in identical trees will result in identical splay paths and identical trees.
\end_layout

\begin_layout Standard
Most of the busywork in that proof seems to be showing that if I add a leaf
 to the starting tree, and then splay the same sequence, then there will
 be no difference in the execution.
\end_layout

\begin_layout Section
Combs (Insertion Trees of Postorders)
\end_layout

\begin_layout Standard
Knowing that splay-insertion of a postorder 
\begin_inset Formula $\pi$
\end_inset

 is identical to splaying 
\begin_inset Formula $\pi$
\end_inset

 starting from 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

, it is natural to enquire about the nature of 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "Chaudhuri1991"

\end_inset

, Chaudhuri and and Hoft show that splaying a search tree in its own 
\emph on
preorder
\emph default
 takes linear time.
 The fact 
\begin_inset Formula $\treap\left(\operatorname{preorder}\left(T\right)\right)=T$
\end_inset

 may obscure the fact that their problem is identical 
\emph on
splay-inserting
\emph default
 in preorder.
 The insertion trees produced by postorders have a very simple, and somewhat
 surprising structure.
 In what follows, 
\begin_inset Formula $x\prec_{\pi}y$
\end_inset

, or simply 
\begin_inset Formula $x\prec y$
\end_inset

 denotes that 
\begin_inset Formula $x$
\end_inset

 precedes 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\pi$
\end_inset

 be a postorder.
 Then all descendants of left children in 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 are left children.
\end_layout

\begin_layout Proof
We show that we would otherwise obtain a contradiction.
 Let 
\begin_inset Formula $w$
\end_inset

 be a left child in 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 with a proper descendent 
\begin_inset Formula $z$
\end_inset

 which is a right child.
 Let 
\begin_inset Formula $y=\parent\left(z\right)$
\end_inset

 and 
\begin_inset Formula $x=\parent\left(w\right)$
\end_inset

.
 As 
\begin_inset Formula $z$
\end_inset

 is 
\begin_inset Formula $y$
\end_inset

's right child, 
\begin_inset Formula $y<z$
\end_inset

.
 Because both 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are descendants of 
\begin_inset Formula $w=\leftnode\left(x\right)$
\end_inset

, they are both in 
\begin_inset Formula $x$
\end_inset

's left subtree, hence 
\begin_inset Formula $y<z<x$
\end_inset

.
 Further, 
\begin_inset Formula $y$
\end_inset

 is an ancestor of 
\begin_inset Formula $z$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 is an ancestor of 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Proof
By the properties of the heap-order, 
\begin_inset Formula $y$
\end_inset

 can be an ancestor of 
\begin_inset Formula $z$
\end_inset

 only if 
\begin_inset Formula $y\prec_{\pi}z$
\end_inset

, and similarly we must have 
\begin_inset Formula $x\prec_{\pi}y$
\end_inset

.
 We thus have that 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 is a subsequence of 
\begin_inset Formula $\pi$
\end_inset

, and from the above, 
\begin_inset Formula $\left(xyz\right)$
\end_inset

 is order-isomorphic to 
\begin_inset Formula $312$
\end_inset

, meaning 
\begin_inset Formula $\pi$
\end_inset

 is not a postorder.
\end_layout

\begin_layout Standard
From the above, if 
\begin_inset Formula $\pi$
\end_inset

 is a postorder, then letting 
\begin_inset Formula $T=\treap\left(\pi\right)$
\end_inset

, the path from 
\begin_inset Formula $\root\left(T\right)$
\end_inset

 to 
\begin_inset Formula $x\in T$
\end_inset

 always consists first of zero or more right children followed by zero or
 more left children.
 The shape this describes in general is a 
\begin_inset Quotes eld
\end_inset

right path
\begin_inset Quotes erd
\end_inset

 with 
\begin_inset Quotes eld
\end_inset

left paths
\begin_inset Quotes erd
\end_inset

 hanging from it to fill in the gaps.
 I will call any such structure a 
\begin_inset Quotes eld
\end_inset

(left-toothed) comb.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Comb"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comb
\end_layout

\end_inset

A 
\emph on
comb
\emph default
 
\begin_inset Formula $C$
\end_inset

 corresponding to the interval partition 
\begin_inset Formula $1\le b_{1}<b_{2}<\cdots<b_{k}=n$
\end_inset

 is a binary search tree with nodes 
\begin_inset Formula $1\dots n$
\end_inset

 whose structure is as follows (for convenience define 
\begin_inset Formula $b_{0}=0$
\end_inset

):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $b_{1}=\root\left(C\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $b_{i+1}=\rightnode\left(b_{i}\right)$
\end_inset

,
\begin_inset space \qquad{}
\end_inset

for 
\begin_inset Formula $1\le i<k$
\end_inset

 when 
\begin_inset Formula $k>1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "Def-Left-Path"

\end_inset


\begin_inset Formula $j=\leftnode\left(j+1\right)$
\end_inset

, 
\begin_inset space \qquad{}
\end_inset

for 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

 and 
\begin_inset Formula $1\le i\le k$
\end_inset


\end_layout

\end_deeper
\begin_layout Definition
We refer to the interval 
\begin_inset Formula $B_{i}=(b_{i-1},b_{i}]$
\end_inset

 as the 
\begin_inset Formula $i\textsuperscript{th}$
\end_inset

 
\emph on
bin
\emph default
 or 
\emph on

\begin_inset Quotes eld
\end_inset

tooth
\begin_inset Quotes erd
\end_inset

 
\emph default
on the comb.
\end_layout

\begin_layout Standard
Combs have several other properties which are not proven here or used for
 this investigation, but which are interesting:
\end_layout

\begin_layout Itemize
For a postorder 
\begin_inset Formula $\pi$
\end_inset

, the comb given by 
\begin_inset Formula $\treap\left(\pi\right)$
\end_inset

 corresponds to the maximal subsequence 
\begin_inset Formula $\left(\pi_{a_{1}}\dots\pi_{a_{k}}\right)$
\end_inset

 of 
\begin_inset Formula $\pi$
\end_inset

 so that 
\begin_inset Formula $\pi_{j}<\pi_{a_{i}}$
\end_inset

 for 
\begin_inset Formula $j<a_{i}$
\end_inset

, for 
\begin_inset Formula $1\le i\le k$
\end_inset

.
\end_layout

\begin_layout Itemize
For every comb 
\begin_inset Formula $C$
\end_inset

, there is a corresponding postorder sequence whose insertion tree is 
\begin_inset Formula $C$
\end_inset

.
 In fact, the 
\emph on
preorder
\emph default
 of 
\begin_inset Formula $C$
\end_inset

 is also a 
\emph on
postorder
\emph default
 whose insertion tree is 
\begin_inset Formula $C$
\end_inset

.
 Note, however, that the tree whose postorder sequence is 
\begin_inset Formula $C$
\end_inset

's preorder will not (in general) be 
\begin_inset Formula $C$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In fact, this tree may be obtained by reversing the labels on each tooth
 of the comb, and then rotating the whole tree 
\begin_inset Formula $90^{\circ}$
\end_inset

 counterclockwise.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Each division of bins on a comb corresponds to an interval partition of
 
\begin_inset Formula $\left[n\right]$
\end_inset

, which itself corresponds to some subset of 
\begin_inset Formula $\left[n-1\right]$
\end_inset

.
 Hence there are 
\begin_inset Formula $2^{n-1}$
\end_inset

 combs on 
\begin_inset Formula $n$
\end_inset

 nodes.
\end_layout

\begin_layout Section
Traversing the Comb
\end_layout

\begin_layout Standard
By itself, the structure of a comb does not help us very much.
 If 
\begin_inset Formula $\tau$
\end_inset

 is an 
\emph on
arbitrary 
\emph default
permutation (such as the bit reversal permutation described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Wilber1989"

\end_inset

), then even the optimal
\emph on
 
\emph default
algorithm can take super-linear time starting from 
\begin_inset Formula $\treap\left(\tau\right)$
\end_inset

 (or any other tree).
 Further, computing the costs of splaying a postorder starting from an arbitrary
 
\emph on
comb
\emph default
 does not seem much easier than starting from any other tree.
\end_layout

\begin_layout Standard
Given a comb 
\begin_inset Formula $C=\left(B_{1},\dots,B_{k}\right)$
\end_inset

, we want to characterize all permutations 
\begin_inset Formula $\pi$
\end_inset

 so that 
\begin_inset Formula $\pi$
\end_inset

 is a postorder such that 
\begin_inset Formula $\treap\left(\pi\right)=C$
\end_inset

.
 We will call these 
\emph on
matching postorders 
\emph default
for 
\begin_inset Formula $C$
\end_inset

.
 The following subroutine, 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

, will be useful:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $\textsc{MultiPush}\left(Q,R\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Input Two stacks 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Algorithm (num)
while 
\begin_inset Formula $R\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{Push}\left(Q,\textsc{Pop}\left(R\right)\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
endwhile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few notes and conventions for what follows.
 The top of a stack is on the 
\emph on
left
\emph default
.
 Each bin 
\begin_inset Formula $B_{i}$
\end_inset

 is treated as a stack of items 
\begin_inset Formula $\left\{ b_{i-1}+1,b_{i-1}+2,\dots,b_{i}\right\} $
\end_inset

.
 The stack 
\begin_inset Formula $B$
\end_inset

 is treated as a 
\begin_inset Quotes eld
\end_inset

stack of bins.
\begin_inset Quotes erd
\end_inset

 The keyword 
\begin_inset Formula $\textsc{Continue}$
\end_inset

 merely means to continue to the next iteration of the loop.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "MatchingPostorder"

\end_inset


\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset


\begin_inset Formula $\left(C\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Input A nonempty comb 
\begin_inset Formula $C$
\end_inset

 with bins 
\begin_inset Formula $B_{1}\dots B_{k}$
\end_inset

 
\end_layout

\begin_layout Algorithm (num)
* Initialize stacks 
\begin_inset Formula $S={\{}{\}}$
\end_inset

, 
\begin_inset Formula $B={\{}B_{1}\dots B_{k}{\}}$
\end_inset


\end_layout

\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop1"

\end_inset


\end_layout

\begin_layout Algorithm (num)
while 
\begin_inset Formula $S\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\series bold
print 
\series default

\begin_inset Formula $\textsc{Pop}\left(S\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop2"

\end_inset


\end_layout

\begin_layout Algorithm (num)
if 
\begin_inset Formula $S=\varnothing$
\end_inset

 and 
\begin_inset Formula $B\ne\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop3"

\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
elseif 
\begin_inset Formula $B=\varnothing$
\end_inset


\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* 
\begin_inset Formula $\textsc{Continue}$
\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
else
\end_layout

\begin_deeper
\begin_layout Algorithm (num)
* Choose between 
\begin_inset Formula $\textsc{Continue}$
\end_inset

 and 
\begin_inset Formula $\textsc{MultiPush}\left(S,\textsc{Pop}\left(B\right)\right)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Pop4"

\end_inset


\end_layout

\end_deeper
\begin_layout Algorithm (num)
endif
\end_layout

\end_deeper
\begin_layout Algorithm (num)
endwhile
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will prove that a permutation 
\begin_inset Formula $\pi$
\end_inset

 is compatible with comb 
\begin_inset Formula $C$
\end_inset

 if and only if it is a possible output of 
\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset

.
\end_layout

\begin_layout Subsection
Outputs are Permutations
\end_layout

\begin_layout Standard
Before proving our main results, we need to perform more basic sanity checks
 on our algorithm.
\end_layout

\begin_layout Lemma
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Correctness
\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 never pops from an empty stack.
\end_layout

\begin_layout Proof
There are four locations in the program at which a 
\begin_inset Formula $\textsc{Pop}$
\end_inset

 can occur: Lines 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
\end_layout

\begin_layout Proof
The first 
\begin_inset Formula $\textsc{Pop}$
\end_inset

 is in the initialization step at Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

.
 Because the comb is nonempty, it will have at least one bin, and therefore
 
\begin_inset Formula $B$
\end_inset

 will be nonempty when 
\begin_inset Formula $\textsc{Pop}\left(B\right)$
\end_inset

 is called.
 The check in the 
\series bold
while
\series default
 loop that 
\begin_inset Formula $S\ne\varnothing$
\end_inset

 ensures that 
\begin_inset Formula $S$
\end_inset

 is nonempty whenever 
\begin_inset Formula $\textsc{Pop}\left(S\right)$
\end_inset

 is called in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

.
 If 
\begin_inset Formula $S$
\end_inset

 
\emph on
is
\emph default
 empty, then the algorithm terminates, and no more pops are performed.
\end_layout

\begin_layout Proof
The call 
\begin_inset Formula $\textsc{Pop}\left(B\right)$
\end_inset

 in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 is only performed after verifying in the preceding line that 
\begin_inset Formula $B$
\end_inset

 is nonempty.
 Similarly, we are only allowed to proceed to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

 if 
\begin_inset Formula $B$
\end_inset

 is nonempty, at which point we are allowed to choose to pop an element
 from 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Termination"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Termination
\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 always terminates.
\end_layout

\begin_layout Proof
At every iteration of the 
\series bold
while
\series default
 loop, one element is removed from 
\begin_inset Formula $S$
\end_inset

.
 The only way elements may be added to 
\begin_inset Formula $S$
\end_inset

 is by a 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

 from a bin on top of 
\begin_inset Formula $B$
\end_inset

.
 There are at most 
\begin_inset Formula $k$
\end_inset

 bins totaling 
\begin_inset Formula $n$
\end_inset

 elements which may be added to 
\begin_inset Formula $S$
\end_inset

.
 Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, it is removed from 
\begin_inset Formula $B$
\end_inset

 and its elements are emptied.
 Hence 
\begin_inset Formula $S$
\end_inset

 may increase in size at most 
\begin_inset Formula $n$
\end_inset

 times, and decreases in size at every iteration of the while loop.
 Thus 
\begin_inset Formula $S$
\end_inset

 will be empty after at most 
\begin_inset Formula $n$
\end_inset

 iterations, at which point loop terminates.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "S-is-emptied"

\end_inset

Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, every element in that bin will eventually be popped from 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Proof
The algorithm always terminates, and the only way for it to terminate is
 when 
\begin_inset Formula $S$
\end_inset

 is empty.
 The only mechanism by which items are removed from 
\begin_inset Formula $S$
\end_inset

 is when they are popped at Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

.
 Hence once the items of a bin are added to 
\begin_inset Formula $S$
\end_inset

, they will all eventually be popped.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "All-bins-added"

\end_inset

Every bin is added to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
We will use induction on 
\begin_inset Formula $k$
\end_inset

.
 Observe that when 
\begin_inset Formula $k=1$
\end_inset

, the bin 
\begin_inset Formula $B_{1}$
\end_inset

 is added to 
\begin_inset Formula $S$
\end_inset

 in the initialization stage.
 Suppose that for combs with 
\begin_inset Formula $k-1$
\end_inset

 bins, all bins will be added to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $C$
\end_inset

 be a comb with 
\begin_inset Formula $k$
\end_inset

 bins, and consider the execution of the algorithm immediately after 
\begin_inset Formula $B_{k-1}$
\end_inset

 is added to 
\begin_inset Formula $S$
\end_inset

, either in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
 In all three cases, 
\begin_inset Formula $S$
\end_inset

 is nonempty, and the algorithm will proceed to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 after the 
\series bold
while
\series default
 loop.
\end_layout

\begin_layout Proof
After Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

, one of three things will happen.
 First, if 
\begin_inset Formula $S$
\end_inset

 is empty, then the algorithm will move to Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

, and add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack.
 If 
\begin_inset Formula $S$
\end_inset

 is nonempty, we will proceed to 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

.
 If the algorithm chooses to add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack, we are done.
 Otherwise, the algorithm may choose to continue to the next iteration of
 the 
\series bold
while
\series default
 loop.
 Each time it does so, 
\begin_inset Formula $S$
\end_inset

 will decrease by one element.
 Hence we can only choose not to add 
\begin_inset Formula $B_{k}$
\end_inset

 to the stack a finite number of times before eventually triggering Line
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

, which will add 
\begin_inset Formula $B_{k}$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "Items-appear-at-least-once"

\end_inset

Every element in the comb 
\begin_inset Formula $C$
\end_inset

 appears in the output of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

.
\end_layout

\begin_layout Proof
Every element in comb 
\begin_inset Formula $C$
\end_inset

 is in one of the bins.
 Every bin is added to 
\begin_inset Formula $S$
\end_inset

 by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "All-bins-added"

\end_inset

.
 Once a bin is added to 
\begin_inset Formula $S$
\end_inset

, all of the bin's elements will eventually be popped from 
\begin_inset Formula $S$
\end_inset

 by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "S-is-emptied"

\end_inset

.
 Every element popped from 
\begin_inset Formula $S$
\end_inset

 is printed in the output, hence all elements in 
\begin_inset Formula $C$
\end_inset

 appear in the output.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Items-appear-at-most-once"

\end_inset

No element of 
\begin_inset Formula $C$
\end_inset

 appears more than once in the output.
\end_layout

\begin_layout Proof
The bins of 
\begin_inset Formula $C$
\end_inset

 form a partition of the nodes, hence each element appears in exactly one
 bin, and only once in that bin.
 As each bin is destroyed once its elements are added to 
\begin_inset Formula $S$
\end_inset

, the elements of a bin can only be added to 
\begin_inset Formula $S$
\end_inset

 once.
 The 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

 of popped bins is the only mechanism by which items enter 
\begin_inset Formula $S$
\end_inset

.
 Taken together, these facts mean that no element of 
\begin_inset Formula $C$
\end_inset

 enters 
\begin_inset Formula $S$
\end_inset

 more than once.
\end_layout

\begin_layout Theorem
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 outputs a permutation of the nodes of 
\begin_inset Formula $C$
\end_inset

 and then terminates.
\end_layout

\begin_layout Proof
By Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "Items-appear-at-least-once"

\end_inset

, every node in 
\begin_inset Formula $C$
\end_inset

 appears in the output, and by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Items-appear-at-most-once"

\end_inset

, no node appears more than once, meaning 
\begin_inset Formula $\textsc{MatchingPostorder}$
\end_inset

 outputs a permutation.
 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Termination"

\end_inset

, the algorithm then terminates.
\end_layout

\begin_layout Subsection
Outputs are Valid Postorders
\end_layout

\begin_layout Standard
For the following theorems, suppose that 
\begin_inset Formula $C=B_{1}\dots B_{k}$
\end_inset

 is a comb let 
\begin_inset Formula $\pi_{\le i}=\left(\pi_{1}\dots\pi_{i}\right)$
\end_inset

 denote the items printed during the first 
\begin_inset Formula $i$
\end_inset

 executions of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "ShapesMatch"

\end_inset

Let 
\begin_inset Formula $T_{i}=\treap\left(\pi_{\le i}\right)$
\end_inset

.
 Then 
\begin_inset Formula $T_{i}$
\end_inset

 is a connected subtree of the root of 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
We use induction on 
\begin_inset Formula $i$
\end_inset

.
 When 
\begin_inset Formula $i=1$
\end_inset

 then the execution of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 occurs immediately after the initialization, during which 
\begin_inset Formula $B_{1}$
\end_inset

 was added to 
\begin_inset Formula $S$
\end_inset

.
 As the elements of 
\begin_inset Formula $B_{1}$
\end_inset

 are added to 
\begin_inset Formula $S$
\end_inset

 in symmetric order, 
\begin_inset Formula $b_{1}$
\end_inset

 is at the top of the stack after the execution of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop1"

\end_inset

, and 
\begin_inset Formula $b_{1}$
\end_inset

 is the first node output.
\end_layout

\begin_layout Proof
Suppose that the theorem is true for the first 
\begin_inset Formula $i-1$
\end_inset

 outputs by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

, and suppose that 
\begin_inset Formula $T_{i-1}$
\end_inset

 has 
\begin_inset Formula $b_{1}\dots b_{l}$
\end_inset

 as the right path.
 We wish show that 
\begin_inset Formula $T_{i}$
\end_inset

 is a connected subtree of the root of 
\begin_inset Formula $C$
\end_inset

.
 We begin by establishing that if 
\begin_inset Formula $B$
\end_inset

 is nonempty immediately after outputting 
\begin_inset Formula $\pi_{i-1}$
\end_inset

 then 
\begin_inset Formula $B_{l+1}$
\end_inset

 is at the top of 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Proof
Whenever Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 pops bin 
\begin_inset Formula $j$
\end_inset

 from 
\begin_inset Formula $B$
\end_inset

, it immediately adds 
\begin_inset Formula $b_{j-1}+1\dots b_{j}$
\end_inset

 to the top of 
\begin_inset Formula $S$
\end_inset

, in that order.
 In particular, 
\begin_inset Formula $b_{j}$
\end_inset

 is at the top of 
\begin_inset Formula $S$
\end_inset

, thus if 
\begin_inset Formula $B_{j}$
\end_inset

 is popped from 
\begin_inset Formula $B$
\end_inset

 then the next node output by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 is always 
\begin_inset Formula $b_{j}$
\end_inset

.
 Note further that when 
\begin_inset Formula $b_{j}$
\end_inset

 is on top of 
\begin_inset Formula $S$
\end_inset

 it is the largest node to have entered 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose for contradiction that 
\begin_inset Formula $B_{l+1}$
\end_inset

 was popped from 
\begin_inset Formula $B$
\end_inset

 prior to iteration 
\begin_inset Formula $i-1$
\end_inset

.
 By the above argument, 
\begin_inset Formula $b_{l+1}$
\end_inset

 is output at the the next iteration of the 
\series bold
while
\series default
 loop, hence 
\begin_inset Formula $b_{l+1}\in T_{i-1}$
\end_inset

.
 Furthermore, 
\begin_inset Formula $b_{l+1}$
\end_inset

 is larger than any node preceding it in the output, hence 
\begin_inset Formula $b_{l+1}$
\end_inset

 is on the right path of 
\begin_inset Formula $T_{i-1}$
\end_inset

, contradicting our assumption.
\end_layout

\begin_layout Proof
From this it follows that if 
\begin_inset Formula $\textsc{Pop}\left(B\right)$
\end_inset

 is executed either in Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop3"

\end_inset

 or Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop4"

\end_inset

 then 
\begin_inset Formula $\pi_{i}=b_{l+1}$
\end_inset

, and 
\begin_inset Formula $b_{l+1}$
\end_inset

 is correctly located as the right child of 
\begin_inset Formula $b_{l}$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

, and 
\begin_inset Formula $T_{i}$
\end_inset

 is a subtree of 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
Otherwise a node 
\begin_inset Formula $j$
\end_inset

 is popped from the top of 
\begin_inset Formula $S$
\end_inset

, and 
\begin_inset Formula $j\in B_{h}$
\end_inset

 for some 
\begin_inset Formula $1\le h\le l$
\end_inset

.
 Recall that the nodes of 
\begin_inset Formula $B_{h}$
\end_inset

 were added in order to 
\begin_inset Formula $S$
\end_inset

, hence they must be popped in reverse order.
 This means that nodes 
\begin_inset Formula $q$
\end_inset

 for which 
\begin_inset Formula $j<q\le b_{h}$
\end_inset

 have already been added to 
\begin_inset Formula $T_{i-1}$
\end_inset

.
 By the induction hypothesis they have been correctly shaped as a leftward
 chain ending in node 
\begin_inset Formula $j+1$
\end_inset

, thus 
\begin_inset Formula $j$
\end_inset

 is placed in the proper position as the left child of 
\begin_inset Formula $j+1$
\end_inset

.
 Again 
\begin_inset Formula $T_{i}$
\end_inset

 forms a connected subtree of the root of 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Monotone"

\end_inset

The stack 
\begin_inset Formula $S$
\end_inset

 is always monotonically decreasing from left-to-right (top-to-bottom).
\end_layout

\begin_layout Proof
Observe that if 
\begin_inset Formula $i<j$
\end_inset

 then then 
\begin_inset Formula $p<q$
\end_inset

 for 
\begin_inset Formula $p\in B_{i}$
\end_inset

 and 
\begin_inset Formula $q\in B_{j}$
\end_inset

.
 Further, if 
\begin_inset Formula $i<j$
\end_inset

 then 
\begin_inset Formula $\textsc{MultiPush}\left(S,B_{i}\right)$
\end_inset

 is always called before 
\begin_inset Formula $\textsc{MultiPush}\left(S,B_{j}\right)$
\end_inset

.
 Finally, 
\begin_inset Formula $\textsc{MultiPush}$
\end_inset

 always adds elements from 
\begin_inset Formula $B_{i}$
\end_inset

 in their symmetric order, hence when a node is pushed onto 
\begin_inset Formula $S$
\end_inset

, it is larger than every other element which had been added to 
\begin_inset Formula $S$
\end_inset

 before it.
 The only way elements are removed is by popping 
\begin_inset Formula $S$
\end_inset

 at the top, so no inversions are ever created among nodes sitting on 
\begin_inset Formula $S$
\end_inset

.
 We thus have 
\begin_inset Formula $S$
\end_inset

 is always decreasing from top to bottom.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "AlgMakesPostorders"

\end_inset


\begin_inset Formula $\pi_{\le i}$
\end_inset

 is 
\begin_inset Formula $312$
\end_inset

-avoiding.
\end_layout

\begin_layout Proof
Once again we induct on 
\begin_inset Formula $i$
\end_inset

.
 When 
\begin_inset Formula $i=1$
\end_inset

, 
\begin_inset Formula $b_{1}$
\end_inset

 is output and the sequence is vacuously 
\begin_inset Formula $312$
\end_inset

-avoiding.
 Suppose 
\begin_inset Formula $\pi_{1}\dots\pi_{i-1}$
\end_inset

 avoids 
\begin_inset Formula $312$
\end_inset

.
 We will show that 
\begin_inset Formula $\pi_{1}\dots\pi_{i}$
\end_inset

 must also avoid 
\begin_inset Formula $312$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose for contradiction that 
\begin_inset Formula $\pi_{\le i}$
\end_inset

 has a 
\begin_inset Formula $312$
\end_inset

 violation 
\begin_inset Formula $x\prec_{\pi}y\prec_{\pi}z$
\end_inset

 with 
\begin_inset Formula $y<z<x$
\end_inset

.
 Observe that since 
\begin_inset Formula $\pi_{<i}$
\end_inset

 avoids 
\begin_inset Formula $312$
\end_inset

, we must have 
\begin_inset Formula $z=\pi_{i}$
\end_inset

.
 By the arguments in Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "ShapesMatch"

\end_inset

, the next node 
\begin_inset Formula $\pi_{i}$
\end_inset

 will be of one of the following two types:
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
It is the head of some new bin.
 
\emph default
If 
\begin_inset Formula $\pi_{i}$
\end_inset

 is the top of a new bin then 
\begin_inset Formula $\pi_{i}>x$
\end_inset

 for 
\begin_inset Formula $x\prec_{\pi}\pi_{i}$
\end_inset

.
 As 
\begin_inset Formula $z=\pi_{i}$
\end_inset

 and 
\begin_inset Formula $x\prec_{\pi}z$
\end_inset

, we have 
\begin_inset Formula $x<z$
\end_inset

, contradicting the assumption that 
\begin_inset Formula $\left(xyz\right)$
\end_inset

 was a 
\begin_inset Formula $312$
\end_inset

-violation.
\end_layout

\begin_layout Enumerate

\emph on
It is the smallest node popped so far from some bin whose head appears in
 
\begin_inset Formula $\pi_{<i}$
\end_inset

.

\emph default
 In this case 
\begin_inset Formula $\pi_{i}\in B_{j}$
\end_inset

 for some 
\begin_inset Formula $j$
\end_inset

.
 Recall that 
\begin_inset Formula $j<l$
\end_inset

 implies 
\begin_inset Formula $p<q$
\end_inset

 for 
\begin_inset Formula $p\in B_{j}$
\end_inset

 and 
\begin_inset Formula $q\in B_{l}$
\end_inset

.
 As 
\begin_inset Formula $b_{j}$
\end_inset

 was the first node output from a bin 
\begin_inset Formula $B_{l}$
\end_inset

 where 
\begin_inset Formula $l\ge j$
\end_inset

, every other node preceding 
\begin_inset Formula $b_{j}$
\end_inset

 in 
\begin_inset Formula $\pi$
\end_inset

 is less than every node in 
\begin_inset Formula $B_{j}$
\end_inset

, and in particular less than 
\begin_inset Formula $\pi_{i}$
\end_inset

.
 We thus have 
\begin_inset Formula $b_{j}\preccurlyeq_{\pi}x\prec_{\pi}y$
\end_inset

.
 By these arguments, 
\begin_inset Formula $y<\pi_{i}$
\end_inset

 must appear before 
\begin_inset Formula $\pi_{i}$
\end_inset

 but after the element 
\begin_inset Formula $b_{j}>\pi_{i}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 always outputs by popping the node at the top of 
\begin_inset Formula $S$
\end_inset

.
 Thus every node in 
\begin_inset Formula $C$
\end_inset

 appearing after the iteration of the 
\series bold
while
\series default
 loop which adds 
\begin_inset Formula $\pi_{i}$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

, but before the iteration which prints 
\begin_inset Formula $\pi_{i}$
\end_inset

, must be to the left of 
\begin_inset Formula $\pi_{i}$
\end_inset

 in 
\begin_inset Formula $S$
\end_inset

 at the time it is printed.
 As 
\begin_inset Formula $\pi_{i}$
\end_inset

 is sitting on 
\begin_inset Formula $S$
\end_inset

 when 
\begin_inset Formula $b_{j}$
\end_inset

 is output, every node in 
\begin_inset Formula $C$
\end_inset

 appearing between 
\begin_inset Formula $b_{j}$
\end_inset

 and 
\begin_inset Formula $\pi_{i}$
\end_inset

 in 
\begin_inset Formula $\pi$
\end_inset

 was sitting to the left of 
\begin_inset Formula $\pi_{i}$
\end_inset

 at the time it was output.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

But by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Monotone"

\end_inset

, this means 
\begin_inset Formula $b_{j}\prec_{\pi}y\prec\pi_{i}$
\end_inset

 implies that 
\begin_inset Formula $y>z=\pi_{i}$
\end_inset

, contradicting our assumption.
\end_layout

\end_deeper
\begin_layout Proof
We thus have 
\begin_inset Formula $\pi_{\le i}$
\end_inset

 does not contain a 
\begin_inset Formula $312$
\end_inset

 violation, and the lemma holds.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:AlgMakesMatchingPostorders"

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 outputs matching postorders for 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
Apply Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "AlgMakesPostorders"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "ShapesMatch"

\end_inset

 with 
\begin_inset Formula $i=n$
\end_inset

.
\end_layout

\begin_layout Subsection
Only Outputs are Matching Postorders
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "NecSucc-Comb"

\end_inset

Let 
\begin_inset Formula $C$
\end_inset

 be a comb corresponding to partition 
\begin_inset Formula $1\le b_{1}<\dots<b_{k}=n$
\end_inset

, 
\begin_inset Formula $\tau$
\end_inset

 a permutation the nodes of 
\begin_inset Formula $C$
\end_inset

, and 
\begin_inset Formula $T=\treap\left(\tau\right)$
\end_inset

.
 Then 
\begin_inset Formula $T=C$
\end_inset

 if and only if:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
Alph*)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Right-Path-Condition"

\end_inset


\begin_inset Formula $b_{i}\prec_{\tau}b_{j}$
\end_inset

 for 
\begin_inset Formula $1\le i<j\le k$
\end_inset

, and
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "Left-Subtrees-Condition"

\end_inset


\begin_inset Formula $j\prec_{\tau}i$
\end_inset

 for 
\begin_inset Formula $b_{l-1}<i<j\le b_{l}$
\end_inset

 and 
\begin_inset Formula $1\le l\le k$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Suppose 
\begin_inset Formula $\tau$
\end_inset

 satisfies conditions 
\begin_inset CommandInset ref
LatexCommand ref
reference "Right-Path-Condition"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
 We must show 
\begin_inset Formula $T$
\end_inset

 satisfies the three properties of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Comb"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
(The root is 
\begin_inset Formula $b_{1}$
\end_inset

.) By Condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Right-Path-Condition"

\end_inset

, 
\begin_inset Formula $b_{1}\prec_{\tau}b_{i}$
\end_inset

 for 
\begin_inset Formula $1<i\le k$
\end_inset

.
 Furthermore, 
\begin_inset Formula $b_{1}\prec_{\tau}j$
\end_inset

 for 
\begin_inset Formula $1\le j<b_{1}$
\end_inset

 by Condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
 Finally by transitivity of the order relation, for all 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

 over 
\begin_inset Formula $1<i\le k$
\end_inset

, we have 
\begin_inset Formula $b_{1}\prec_{\tau}b_{i}\prec_{\tau}j$
\end_inset

.
 Thus 
\begin_inset Formula $b_{1}$
\end_inset

 is the first element of 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $b_{1}=\root\left(T\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
(The right path is 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

.) We induct on 
\begin_inset Formula $k$
\end_inset

, the number of bins.
 If 
\begin_inset Formula $k=1$
\end_inset

 then the root 
\begin_inset Formula $b_{1}$
\end_inset

 is the greatest element in 
\begin_inset Formula $T$
\end_inset

, and all other nodes appear in 
\begin_inset Formula $b_{1}$
\end_inset

's left subtree, hence 
\begin_inset Formula $b_{1}$
\end_inset

 is the sole member of the right path.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Suppose 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $k$
\end_inset

-bins.
 By the heap-condition on first-access time and the symmetric order on the
 keys, the right child of 
\begin_inset Formula $b_{k-1}$
\end_inset

 in 
\begin_inset Formula $T$
\end_inset

 is the first node greater than 
\begin_inset Formula $b_{k-1}$
\end_inset

 appearing after 
\begin_inset Formula $b_{k-1}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
 If 
\begin_inset Formula $b_{k-1}<j<b_{k}$
\end_inset

 then Condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

 assures us that 
\begin_inset Formula $b_{k}\prec_{\tau}j$
\end_inset

.
 As 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $k$
\end_inset

 bins, 
\begin_inset Formula $b_{k}=\max\left(\tau\right)$
\end_inset

, hence 
\begin_inset Formula $b_{k}$
\end_inset

 has no right children, and no elements greater than 
\begin_inset Formula $b_{k-1}$
\end_inset

 appear before 
\begin_inset Formula $b_{k}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Summarizing, 
\begin_inset Formula $b_{1}$
\end_inset

 is the root, 
\begin_inset Formula $b_{i+1}=\rightnode\left(b_{i}\right)$
\end_inset

 for 
\begin_inset Formula $1<i\le k$
\end_inset

, and 
\begin_inset Formula $b_{k}$
\end_inset

 has no right child.
 The nodes 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 thus form the right path of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Enumerate
(The left subtrees of 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 are chains.)
\series bold
 
\series default
From above, the nodes 
\begin_inset Formula $b_{1}\dots b_{k}$
\end_inset

 form the right path of 
\begin_inset Formula $T$
\end_inset

, hence the symmetric order implies that the left subtree of 
\begin_inset Formula $b_{i}$
\end_inset

 consists exactly of the nodes 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $b_{i-1}<j<b_{i}$
\end_inset

.
 We use induction on the length of the chains hanging from each 
\begin_inset Formula $b_{i}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

If 
\begin_inset Formula $b_{i-1}$
\end_inset

 is the predecessor of 
\begin_inset Formula $b_{i}$
\end_inset

 in symmetric order then 
\begin_inset Formula $b_{i}$
\end_inset

's left subtree is empty, vacuously matching Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "Def-Left-Path"

\end_inset

 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Comb"

\end_inset

.
 Suppose that all left subtrees of the right path with at least 
\begin_inset Formula $j-1$
\end_inset

 nodes begin with a leftward chain containing the 
\begin_inset Formula $j-1$
\end_inset

 largest nodes of the subtree.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Let 
\begin_inset Formula $b_{i}$
\end_inset

 have a left subtree with at least 
\begin_inset Formula $j$
\end_inset

 nodes, and let 
\begin_inset Formula $a_{0}=b_{i}>a_{1}>a_{2}>\cdots>a_{l}$
\end_inset

 be the nodes of that subtree along with 
\begin_inset Formula $b_{i}$
\end_inset

.
 By the inductive hypothesis, nodes 
\begin_inset Formula $a_{0}\dots a_{j-1}$
\end_inset

 are ancestors of 
\begin_inset Formula $a_{j-1}$
\end_inset

, thus the symmetric order implies that nodes 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 are in the left subtree of 
\begin_inset Formula $a_{j-1}$
\end_inset

, hence one of 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 is the left child of 
\begin_inset Formula $a_{j-1}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The heap condition on first access time implies the left child of 
\begin_inset Formula $a_{j-1}$
\end_inset

 is the first node among 
\begin_inset Formula $a_{j}\dots a_{l}$
\end_inset

 appearing subsequent to 
\begin_inset Formula $a_{j-1}$
\end_inset

 in 
\begin_inset Formula $\tau$
\end_inset

.
 Condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

of the theorem implies that 
\begin_inset Formula $a_{j}\prec_{\tau}a_{h}$
\end_inset

 for 
\begin_inset Formula $j<h<l$
\end_inset

, hence 
\begin_inset Formula $a_{j}=\leftnode\left(a_{j-1}\right)$
\end_inset

, and Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "Def-Left-Path"

\end_inset

 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Comb"

\end_inset

 is satisfied.
\end_layout

\end_deeper
\begin_layout Proof
The other direction may be done more elegantly.
 Suppose 
\begin_inset Formula $\treap\left(\tau\right)\ne C$
\end_inset

, and let 
\begin_inset Formula $i$
\end_inset

 be the largest index so that 
\begin_inset Formula $R=\treap\left(\tau_{1}\dots\tau_{i}\right)$
\end_inset

 is a connected subtree of the root of 
\begin_inset Formula $C$
\end_inset

.
 We show the insertion of 
\begin_inset Formula $q=\tau_{i+1}$
\end_inset

 will violate condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Right-Path-Condition"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
 
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $b_{1}\dots b_{l}$
\end_inset

 be the nodes on the right path of 
\begin_inset Formula $R$
\end_inset

.
 The fact that 
\begin_inset Formula $R$
\end_inset

 is a sub-structure of 
\begin_inset Formula $C$
\end_inset

 constrains the violations which might be introduced by inserting 
\begin_inset Formula $q$
\end_inset

.
 In particular if 
\begin_inset Formula $q\in B_{i}$
\end_inset

 for 
\begin_inset Formula $1\le i\le l$
\end_inset

 then the symmetric order condition ensures that 
\begin_inset Formula $q$
\end_inset

 is inserted as the leftmost node in its corresponding bin.
 Hence all violations are of the following two types:
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
\begin_inset Formula $q$
\end_inset

 is placed on the right path of 
\begin_inset Formula $R$
\end_inset

 at the location where we should find 
\begin_inset Formula $b_{l+1}$
\end_inset

 in 
\begin_inset Formula $C$
\end_inset

.

\emph default
 If 
\begin_inset Formula $q<b_{l+1}$
\end_inset

 then 
\begin_inset Formula $b_{l+1}\prec_{\tau}q$
\end_inset

 for some 
\begin_inset Formula $b_{l}<q<b_{l+1}$
\end_inset

, violating 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
 Otherwise 
\begin_inset Formula $q>b_{l}$
\end_inset

.
 If 
\begin_inset Formula $q=b_{j}$
\end_inset

 for some 
\begin_inset Formula $j>l$
\end_inset

 then 
\begin_inset Formula $b_{j}\prec_{\tau}b_{l}$
\end_inset

 violating 
\begin_inset CommandInset ref
LatexCommand ref
reference "Right-Path-Condition"

\end_inset

.
 Otherwise, if 
\begin_inset Formula $q$
\end_inset

 is not the head of a bin then there is some 
\begin_inset Formula $i$
\end_inset

 for which 
\begin_inset Formula $b_{i-1}<q<b_{i}$
\end_inset

.
 In this case, 
\begin_inset Formula $q$
\end_inset

 appears prior to all other elements, and in particular 
\begin_inset Formula $q\prec_{\tau}b_{i}$
\end_inset

, violating Condition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $q$
\end_inset

 is placed as the left child of some node greater than 
\begin_inset Formula $q+1$
\end_inset


\emph default
.
 We must have 
\begin_inset Formula $b_{i-1}<q<q+1\le b_{i}$
\end_inset

 for some 
\begin_inset Formula $1\le i\le l$
\end_inset

, yet 
\begin_inset Formula $q\prec_{\tau}q+1$
\end_inset

, violating 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Hence every permutation 
\begin_inset Formula $\tau$
\end_inset

 for which 
\begin_inset Formula $T\ne C$
\end_inset

 violates the conditions of the theorem.
\end_layout

\begin_layout Remark
Not all permutations whose insertion trees are combs are postorders.
 A minimal counterexample is 
\begin_inset Formula $\left(2413\right)$
\end_inset

.
\end_layout

\begin_layout Corollary
A permutation 
\begin_inset Formula $\pi$
\end_inset

 is a matching postorder for a comb 
\begin_inset Formula $C$
\end_inset

 with bins 
\begin_inset Formula $B_{1}\dots B_{k}$
\end_inset

 if and only if it is 
\begin_inset Formula $312$
\end_inset

-avoiding and matches conditions 
\begin_inset CommandInset ref
LatexCommand ref
reference "Right-Path-Condition"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "Left-Subtrees-Condition"

\end_inset

 of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "NecSucc-Comb"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

Let 
\begin_inset Formula $C$
\end_inset

 be a comb with bins 
\begin_inset Formula $B_{1}\dots B_{k}$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 elements.
 Let 
\begin_inset Formula $\alpha=\alpha_{1}\dots\alpha_{i}$
\end_inset

 with 
\begin_inset Formula $i<n$
\end_inset

 be the outputs of the first 
\begin_inset Formula $i$
\end_inset

 iterations of the 
\series bold
\emph on
while 
\series default
\emph default
loop in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

.
 Let 
\begin_inset Formula $\tau=\alpha_{1}\dots\alpha_{i}q$
\end_inset

 be the permutation obtained by appending 
\begin_inset Formula $q$
\end_inset

 to 
\begin_inset Formula $\alpha$
\end_inset

.
 If Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 cannot output 
\begin_inset Formula $q$
\end_inset

 at iteration 
\begin_inset Formula $i+1$
\end_inset

, then 
\begin_inset Formula $\tau$
\end_inset

 is not a prefix of any matching postorder for 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $b_{1}\dots b_{l}$
\end_inset

 be the nodes on the right path of 
\begin_inset Formula $T=\treap\left(\alpha\right)$
\end_inset

.
 Let 
\begin_inset Formula $B_{h_{1}}\dots B_{h_{m}}$
\end_inset

 with 
\begin_inset Formula $1\le h_{1}<\cdots<h_{m}\le l$
\end_inset

 be the subsequence of bins 
\begin_inset Formula $B_{1}\dots B_{l}$
\end_inset

 with nodes on 
\begin_inset Formula $S$
\end_inset

 immediately after the execution of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 during iteration 
\begin_inset Formula $i-1$
\end_inset

.
 Let 
\begin_inset Formula $a_{j}$
\end_inset

 for 
\begin_inset Formula $1\le j\le m$
\end_inset

 be the largest node in 
\begin_inset Formula $B_{h_{j}}$
\end_inset

 which is not in 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Proof
In plain English, Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "NecSucc-Comb"

\end_inset

 restricts our choices of 
\begin_inset Formula $q$
\end_inset

 to one of 
\begin_inset Formula $a_{1}\dots a_{m}$
\end_inset

 or 
\begin_inset Formula $b_{l+1}$
\end_inset

, should either 
\begin_inset Formula $m>0$
\end_inset

 or 
\begin_inset Formula $b_{l+1}$
\end_inset

 exist.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 restricts our choices much further: we may output 
\begin_inset Formula $a_{m}$
\end_inset

 or 
\begin_inset Formula $b_{l+1}$
\end_inset

, should either exist.
 We show that choosing 
\begin_inset Formula $q<a_{m}$
\end_inset

 creates a 
\begin_inset Formula $312$
\end_inset

-violation.
 Let 
\begin_inset Formula $1\le j<m$
\end_inset

, suppose 
\begin_inset Formula $q=a_{j}$
\end_inset

, and let 
\begin_inset Formula $\beta$
\end_inset

 be a permutation with prefix 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Proof
By construction, 
\begin_inset Formula $x=a_{m}+1$
\end_inset

 appears before 
\begin_inset Formula $y=a_{j}$
\end_inset

 in both in 
\begin_inset Formula $\tau$
\end_inset

 and in 
\begin_inset Formula $\beta$
\end_inset

.
 Furthermore, 
\begin_inset Formula $z=a_{m}$
\end_inset

 must appear somewhere after 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $\beta$
\end_inset

 since 
\begin_inset Formula $\beta$
\end_inset

 is a permutation and 
\begin_inset Formula $z$
\end_inset

 does not appear in 
\begin_inset Formula $\beta$
\end_inset

's prefix, 
\begin_inset Formula $\tau$
\end_inset

.
 Finally we observe that 
\begin_inset Formula $a_{j}<a_{m}<a_{m}+1$
\end_inset

.
 We have thus exhibited 
\begin_inset Formula $x\prec_{\beta}y\prec_{\beta}z$
\end_inset

 so that 
\begin_inset Formula $y<z<x$
\end_inset

, hence 
\begin_inset Formula $\beta$
\end_inset

 has a 
\begin_inset Formula $312$
\end_inset

-violation.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $C$
\end_inset

 be a comb.
 Then 
\begin_inset Formula $\pi$
\end_inset

 is a matching postorder for 
\begin_inset Formula $C$
\end_inset

 if and only if it is a valid output of 
\begin_inset Formula $\textsc{MatchingPostorder}\left(C\right)$
\end_inset

.
\end_layout

\begin_layout Proof
A straightforward application of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:AlgMakesMatchingPostorders"

\end_inset

 and Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

.
\end_layout

\begin_layout Section
Splaying a Comb's Matching Postorder
\end_layout

\begin_layout Standard
There are a few things with noting about the preceding material.
 Our method of showing equivalence between executions of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "MatchingPostorder"

\end_inset

 and the matching postorders of a comb does not even establish a bijection
 (although I believe there is).
 We merely showed that its outputs are always postorders, and non-outputs
 cannot be postorders.
 We have't even counted the number postorders matching a comb!
\end_layout

\begin_layout Standard
Perhaps more remarkable: we have barely even mentioned 
\begin_inset Quotes eld
\end_inset

splaying,
\begin_inset Quotes erd
\end_inset

 have made one use of the word 
\begin_inset Quotes eld
\end_inset

cost,
\begin_inset Quotes erd
\end_inset

 and the strings 
\begin_inset Quotes eld
\end_inset

depth
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

rotation
\begin_inset Quotes erd
\end_inset

 do not appear prior to this sentence.
 That's quite an achievement for the first 11 pages of a writeup on binary
 search tree algorithms!
\end_layout

\begin_layout Standard
The bulk of the work in this paper is indeed behind us.
 Its fair to say that most of it is about combinatorial constraints on ordering
 relations, which are useful here since 
\begin_inset Formula $312$
\end_inset

-avoidance is a very strong condition on a permutation.
 Strategically, the strategy has been to suss out all of the combinatorial
 constraints that it buys us and write them in an algorithmically useful
 fashion.
 More whimsically, this paper could be 
\begin_inset Quotes eld
\end_inset

postorders are actually pretty easy sequences to insert into empty trees.
\begin_inset Quotes erd
\end_inset

 Getting back to actual work\SpecialChar ldots

\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $C$
\end_inset

 be a comb with bins 
\begin_inset Formula $B_{1}\dots B_{k}$
\end_inset

 and let 
\begin_inset Formula $\pi=\pi_{1}\dots\pi_{n}$
\end_inset

 be a sequence output by 
\begin_inset Formula $\textsc{MatchingPostorder}\left(C\right)$
\end_inset

 and denote 
\begin_inset Formula $\pi_{1}\dots\pi_{i}$
\end_inset

 by 
\begin_inset Formula $\pi_{\le i}$
\end_inset

.
 Let 
\begin_inset Formula $T_{0}=C$
\end_inset

 and let 
\begin_inset Formula $T_{i}$
\end_inset

 be the tree obtained by splaying 
\begin_inset Formula $\pi_{i}$
\end_inset

 in 
\begin_inset Formula $T_{i-1}$
\end_inset

.
 Let 
\begin_inset Formula $d_{i}\left(x\right)$
\end_inset

 be the depth of 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

, where the depth of the root is 1.
\end_layout

\begin_layout Lemma
All nodes in 
\begin_inset Formula $S$
\end_inset

 after the 
\begin_inset Formula $i\textsuperscript{th}$
\end_inset

 execution of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

 must be in the left subtree of 
\begin_inset Formula $T_{i}$
\end_inset

.
\end_layout

\begin_layout Proof
The root of 
\begin_inset Formula $T_{i}$
\end_inset

 is the is the node output by the 
\begin_inset Formula $i\textsuperscript{th}$
\end_inset

 execution of Line 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pop2"

\end_inset

.
 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Monotone"

\end_inset

, all remaining nodes in 
\begin_inset Formula $S$
\end_inset

 are less than the root, hence in the left subtree of 
\begin_inset Formula $T_{i}$
\end_inset

.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $h_{1}\dots h_{m}$
\end_inset

 and 
\begin_inset Formula $a_{1}\dots a_{m}$
\end_inset

 be as in Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

 at iteration 
\begin_inset Formula $i$
\end_inset

.
 Then the subtree of 
\begin_inset Formula $T_{i}$
\end_inset

 rooted at 
\begin_inset Formula $a_{j}$
\end_inset

 is a leftward chain consisting of nodes 
\begin_inset Formula $b_{h_{j}-1}+1\dots a_{j}$
\end_inset

.
\end_layout

\begin_layout Proof
Each bin begins in 
\begin_inset Formula $T_{0}$
\end_inset

 as a leftward chain.
 By the arguments of Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "NecSucc-Comb"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

 we must splay nodes on these chains in decreasing order, hence we have
 not splayed any of 
\begin_inset Formula $b_{h_{j}-1}+1\dots a_{j}$
\end_inset

 up to the splaying of 
\begin_inset Formula $\pi_{i}$
\end_inset

 for 
\begin_inset Formula $1\le j\le m$
\end_inset

.
 As nodes 
\begin_inset Formula $b_{h_{j}-1}+1\dots a_{j}$
\end_inset

 have no descendents other than themselves, no descendents of these nodes
 have been splayed up through the access of 
\begin_inset Formula $\pi_{i}$
\end_inset

 either.
 By arguments of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:InitialTrees"

\end_inset

, none of 
\begin_inset Formula $b_{h_{j}-1}+1\dots a_{j}$
\end_inset

 are on the splay paths of 
\begin_inset Formula $\pi_{1}\dots\pi_{i}$
\end_inset

, and hence the structure of the chain is unaltered.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $h_{1}\dots h_{m}$
\end_inset

 and 
\begin_inset Formula $a_{1}\dots a_{m}$
\end_inset

 be as in Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

 at iteration 
\begin_inset Formula $i$
\end_inset

, and let 
\begin_inset Formula $e_{j}$
\end_inset

 be the first ancestor of 
\begin_inset Formula $a_{j}$
\end_inset

 on the left path of 
\begin_inset Formula $T_{i}$
\end_inset

.
 Then for 
\begin_inset Formula $j\ne l$
\end_inset

 we have 
\begin_inset Formula $e_{j}\ne e_{l}$
\end_inset

.
\end_layout

\begin_layout Proof
We use induction on 
\begin_inset Formula $i$
\end_inset

.
 When 
\begin_inset Formula $i=1$
\end_inset

 then the only bin whose head has been splayed is 
\begin_inset Formula $B_{1}$
\end_inset

, hence 
\begin_inset Formula $m\le1$
\end_inset

.
 As the first iteration merely splays the root, 
\begin_inset Formula $T_{1}=T_{0}$
\end_inset

 and if 
\begin_inset Formula $a_{1}$
\end_inset

 exists then 
\begin_inset Formula $e_{1}=b_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
Suppose the theorem is true for 
\begin_inset Formula $\pi_{\le i}$
\end_inset

.
 By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:ONLYAlgMakesMatchingPostorders"

\end_inset

, the only candidate nodes 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/Users/clevy/Grad/library"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
